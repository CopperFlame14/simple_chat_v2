<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Two-Way Simple Chat Protocol (SCP)</title>
  <style>
	  .member-photo {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: rgba(94,234,212,0.1);
  margin-right: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--accent);
  font-size: 24px;
  overflow: hidden;
  position: relative;
  flex-shrink: 0; /* Prevents shrinking */
}

.member-photo img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 50%;
}

.default-avatar {
  display: none; /* Hidden by default, shows if image fails */
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}

.team-member {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
}
    :root {
      --bg: #0b0f14;
      --panel: #0f1720;
      --muted: #9aa7b2;
      --accent: #5eead4;
      --glass: rgba(255,255,255,0.03);
      --danger: #ff7b7b;
      --success: #7df59f;
      --client-color: #5eead4;
      --server-color: #7df59f;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      background: linear-gradient(180deg, #071018 0%, #07121a 100%);
      color: var(--muted);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Header and Navigation Styles */
    header {
      text-align: center;
      margin-bottom: 40px;
      padding: 40px 20px;
      background: linear-gradient(135deg, rgba(94,234,212,0.1), rgba(125,245,159,0.1));
      border-radius: 16px;
      border: 1px solid rgba(94,234,212,0.2);
      position: relative;
    }

    .top-buttons {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .top-btn {
      padding: 8px 16px;
      background: var(--panel);
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.3s;
    }

    .top-btn:hover {
      background: rgba(94,234,212,0.1);
      border-color: var(--accent);
      color: var(--accent);
    }

    .top-btn.active {
      background: var(--accent);
      color: #0b0f14;
      font-weight: 600;
    }

    h1 {
      color: #e6f3f2;
      font-size: 2.5em;
      margin-bottom: 10px;
      letter-spacing: 0.5px;
    }

    h2 {
      color: #5eead4;
      margin: 40px 0 20px;
      font-size: 1.8em;
      border-bottom: 2px solid rgba(94,234,212,0.3);
      padding-bottom: 10px;
    }

    h3 {
      color: #7df59f;
      margin: 25px 0 15px;
      font-size: 1.4em;
    }

    .subtitle {
      color: var(--muted);
      font-size: 1.1em;
    }

    .nav-tabs {
      display: flex;
      gap: 10px;
      margin: 30px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    .nav-tabs button {
      padding: 12px 24px;
      background: var(--panel);
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s;
    }

    .nav-tabs button:hover {
      background: rgba(94,234,212,0.1);
      border-color: var(--accent);
      color: var(--accent);
    }

    .nav-tabs button.active {
      background: var(--accent);
      color: #0b0f14;
      font-weight: 600;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.5s;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .section {
      background: var(--panel);
      padding: 30px;
      margin: 20px 0;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.05);
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }

    .code-block {
      background: #000;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 15px 0;
      border: 1px solid rgba(94,234,212,0.2);
    }

    pre {
      margin: 0;
      font-family: var(--mono);
      font-size: 0.9em;
      color: #e6f3f2;
      line-height: 1.5;
    }

    .protocol-diagram {
      background: rgba(94,234,212,0.05);
      padding: 20px;
      border-radius: 8px;
      border: 2px dashed rgba(94,234,212,0.3);
      margin: 20px 0;
      font-family: var(--mono);
      font-size: 0.95em;
    }

    .flow-step {
      background: rgba(125,245,159,0.05);
      padding: 15px;
      margin: 10px 0;
      border-left: 4px solid var(--success);
      border-radius: 4px;
    }

    .highlight {
      color: var(--accent);
      font-weight: 600;
    }

    .warning {
      background: rgba(255,123,123,0.1);
      border-left: 4px solid var(--danger);
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
    }

    .success {
      background: rgba(125,245,159,0.1);
      border-left: 4px solid var(--success);
      padding: 15px;
      border-radius: 4px;
      margin: 15px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    th {
      background: rgba(94,234,212,0.1);
      color: var(--accent);
      font-weight: 600;
    }

    ul, ol {
      margin: 15px 0 15px 30px;
    }

    li {
      margin: 8px 0;
    }

    .simulator-container {
      margin: 30px 0;
    }

    .panels {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      position: relative;
      margin: 20px 0;
    }

    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 10px;
      min-height: 260px;
      flex: 1;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
    }

    .panel-title {
      color: #cfeee2;
      font-weight: 600;
      margin-bottom: 8px;
      font-family: var(--mono);
      font-size: 13px;
    }

    .console {
      background: linear-gradient(0deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      flex: 1;
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
      font-family: var(--mono);
      font-size: 13px;
      color: #dff6ef;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    .console .line {
      margin: 4px 0;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .client-message {
      color: var(--client-color);
    }

    .server-message {
      color: var(--server-color);
    }

    .send-form {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .send-form input {
      flex: 1;
      background: var(--glass);
      border: none;
      padding: 8px 10px;
      border-radius: 8px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .send-form button {
      padding: 8px 12px;
      border-radius: 8px;
      background: linear-gradient(180deg, var(--accent), #39d6b2);
      color: #04221c;
      font-weight: 700;
      border: none;
      cursor: pointer;
    }

    .controls {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: 20px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.03);
      margin: 20px 0;
    }

    .control-row {
      margin: 15px 0;
    }

    .control-row label {
      display: block;
      margin-bottom: 5px;
      color: #e7f6f4;
    }

    input[type="range"] {
      width: 100%;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .floating-msg {
      position: absolute;
      padding: 8px 12px;
      border-radius: 999px;
      font-family: var(--mono);
      font-size: 13px;
      color: #021712;
      box-shadow: 0 8px 24px rgba(5,10,12,0.6);
      white-space: nowrap;
    }

    .floating-client {
      background: linear-gradient(90deg, #a7ffeb, #5eead4);
    }

    .floating-server {
      background: linear-gradient(90deg, #dfffdc, #9ef2b4);
    }

    .floating-ack {
      background: linear-gradient(90deg, #e6f3ff, #b3d9ff);
      color: #001a33;
    }

    .floating-dropped {
      background: linear-gradient(90deg, #ffdada, #ffb5b5);
      color: #3a0000;
      text-decoration: line-through;
    }

    .event-log {
      background: rgba(255,255,255,0.02);
      border-radius: 10px;
      padding: 15px;
      max-height: 200px;
      overflow: auto;
      font-family: var(--mono);
      font-size: 12px;
      margin: 20px 0;
      border: 1px solid rgba(255,255,255,0.02);
    }

    .log-line {
      margin: 6px 0;
    }

    @keyframes toRight {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(var(--dx)); opacity: 1; }
    }

    @keyframes toLeft {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(calc(var(--dx) * -1)); opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; transform: translateY(-6px); }
    }

    @media (max-width: 968px) {
      .panels { flex-direction: column; }
      .top-buttons { position: static; justify-content: center; margin-bottom: 20px; }
    }

    .download-btn {
      display: inline-block;
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--accent), #39d6b2);
      color: #04221c;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      margin: 10px 10px 10px 0;
      transition: transform 0.2s;
    }

    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(94,234,212,0.3);
    }

    footer {
      text-align: center;
      margin-top: 60px;
      padding: 30px;
      border-top: 1px solid rgba(255,255,255,0.1);
      color: var(--muted);
      font-size: 0.9em;
    }

    .bidirectional-flow {
      text-align: center;
      margin: 30px 0;
      padding: 20px;
      background: rgba(94,234,212,0.05);
      border-radius: 12px;
      border: 2px dashed rgba(94,234,212,0.3);
    }

    .bidirectional-flow h3 {
      color: var(--accent);
      margin-bottom: 20px;
    }

    .flow-arrows {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 20px 0;
    }

    .arrow {
      font-size: 2em;
      color: var(--accent);
    }

    .flow-label {
      font-size: 0.9em;
      color: var(--muted);
      margin-top: 5px;
    }

    /* Additional styles for new tabs */
    .team-member {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
    }

    .member-photo {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(94,234,212,0.1);
      margin-right: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 24px;
    }

    .member-info h3 {
      margin: 0 0 5px 0;
    }

    .member-info p {
      margin: 0;
      color: var(--muted);
    }

    .video-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 aspect ratio */
      height: 0;
      overflow: hidden;
      margin: 20px 0;
      border-radius: 8px;
      background: #000;
    }

    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }

    .help-steps {
      margin: 20px 0;
    }

    .help-step {
      margin-bottom: 15px;
      padding: 15px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
    }

    .help-step h4 {
      margin: 0 0 10px 0;
      color: var(--accent);
    }

    .performance-chart {
      background: rgba(255,255,255,0.02);
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }

    .chart-bar {
      height: 30px;
      margin: 10px 0;
      border-radius: 4px;
      display: flex;
      align-items: center;
      padding: 0 15px;
      color: #04221c;
      font-weight: 600;
      transition: width 0.5s ease-in-out;
    }

    .chart-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <!-- RESTORED TOP BUTTONS -->
      <div class="top-buttons">
        <button class="top-btn" data-tab="download">Download</button>
        <button class="top-btn" data-tab="help">Help</button>
        <button class="top-btn" data-tab="learn">Learn</button>
        <button class="top-btn" data-tab="developedBy">Developed by</button>
      </div>
      
      <h1>ğŸ”„ Two-Way Simple Chat Protocol (SCP)</h1>
      <p class="subtitle">Bidirectional Communication with Multi-Threading</p>
      <p class="subtitle" style="margin-top: 10px; font-size: 0.95em;">Full Duplex Protocol with Simultaneous Send/Receive</p>
    </header>

    <nav class="nav-tabs">
      <button class="tab-btn active" data-tab="overview">Overview</button>
      <button class="tab-btn" data-tab="protocol">Protocol Design</button>
      <button class="tab-btn" data-tab="implementation">C Implementation</button>
      <button class="tab-btn" data-tab="simulator">Live Simulator</button>
      <button class="tab-btn" data-tab="results">Results & Testing</button>
    </nav>

    <!-- OVERVIEW TAB -->
    <div id="overview" class="tab-content active">
      <div class="section">
        <h2>ğŸ”„ Two-Way Protocol Overview</h2>
        
        <h3>Key Improvements</h3>
        <div class="bidirectional-flow">
          <h3>ğŸ”„ Bidirectional Communication Flow</h3>
          <div class="flow-arrows">
            <div>
              <div class="arrow">â¬…ï¸</div>
              <div class="flow-label">Server â†’ Client</div>
            </div>
            <div>
              <div class="arrow">â¡ï¸</div>
              <div class="flow-label">Client â†’ Server</div>
            </div>
          </div>
          <p>Both directions work simultaneously with full ACK/retry reliability</p>
        </div>

        <div class="flow-step">
          <strong>ğŸ¯ 1. Bidirectional Messaging</strong>
          <ul>
            <li>Both client and server can send messages simultaneously</li>
            <li>No more "one-way" communication limitation</li>
            <li>Real-time chat experience with mutual acknowledgment</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>ğŸ§µ 2. Multi-Threading Architecture</strong>
          <ul>
            <li><strong>Receive Thread:</strong> Listens for incoming messages continuously</li>
            <li><strong>Send Thread:</strong> Handles user input and outgoing messages</li>
            <li>Both threads run concurrently using POSIX threads (pthread)</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>ğŸ”’ 3. Thread Synchronization</strong>
          <ul>
            <li>Mutex locks (pthread_mutex_t) protect socket operations</li>
            <li>Prevents race conditions when multiple threads access the socket</li>
            <li>Atomic operations for message ID generation</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>âœ¨ 4. Enhanced Features</strong>
          <ul>
            <li>Server can initiate conversations and send messages to client</li>
            <li>Client receives and acknowledges server messages</li>
            <li>Both sides maintain ACK/retry logic in both directions</li>
            <li>Clean separation of send/receive concerns</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>ğŸ”§ 5. Updated Build System</strong>
          <ul>
            <li>Added -pthread flag to Makefile for thread support</li>
            <li>Works on Linux/macOS with standard pthread library</li>
            <li>Windows requires MinGW with pthread support</li>
          </ul>
        </div>

        <h3>Technical Architecture</h3>
        <div class="protocol-diagram">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     CLIENT      â”‚              â”‚     SERVER      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Send Thread    â”‚â—„â”€â”€â”€MSG/ACKâ”€â”€â”€â”‚  Send Thread    â”‚
â”‚  (User Input)   â”‚â”€â”€â”€MSG/ACKâ”€â”€â”€â–ºâ”‚  (Auto Reply)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Receive Thread  â”‚â—„â”€â”€â”€MSG/ACKâ”€â”€â”€â”‚ Receive Thread  â”‚
â”‚  (Continuous)   â”‚â”€â”€â”€MSG/ACKâ”€â”€â”€â–ºâ”‚  (Continuous)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key:
â€¢ Each side has TWO independent threads
â€¢ Messages flow bidirectionally with ACK
â€¢ Threads communicate via shared socket with mutex
â€¢ Full reliability in both directions
</pre>
        </div>

        <div class="success">
          <strong>ğŸ’¡ Learning Outcome:</strong> This implementation demonstrates real-world protocol design where bidirectional communication is essential. You'll understand multi-threading, synchronization, and full-duplex network programming.
        </div>
      </div>
    </div>

    <!-- PROTOCOL DESIGN TAB -->
    <div id="protocol" class="tab-content">
      <div class="section">
        <h2>ğŸ”§ Two-Way Protocol Design</h2>

        <h3>Enhanced Message Flow</h3>
        <div class="protocol-diagram">
<pre>
CLIENT                                    SERVER
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ HELLO (id=0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Connection Setup
  â”‚<â”€â”€â”€â”€ ACK (id=0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ MSG (id=1, "Hello") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Client â†’ Server
  â”‚<â”€â”€â”€â”€ ACK (id=1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚<â”€â”€â”€â”€ MSG (id=100, "Hi Client!") â”€â”€â”€â”€â”€â”€â”€â”€â”‚  Server â†’ Client  
  â”‚â”€â”€â”€â”€ ACK (id=100) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ MSG (id=2, "How are you?") â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Simultaneous!
  â”‚<â”€â”€â”€â”€ MSG (id=101, "I'm good!") â”€â”€â”€â”€â”€â”€â”€â”€â”‚  Both directions!
  â”‚â”€â”€â”€â”€ ACK (id=101) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
  â”‚<â”€â”€â”€â”€ ACK (id=2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
  â”‚â”€â”€â”€â”€ BYE (id=3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Termination
  â”‚<â”€â”€â”€â”€ ACK (id=3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                         â”‚
</pre>
        </div>

        <h3>Thread Architecture</h3>
        <table>
          <tr>
            <th>Component</th>
            <th>Client</th>
            <th>Server</th>
            <th>Purpose</th>
          </tr>
          <tr>
            <td><strong>Main Thread</strong></td>
            <td>Setup & cleanup</td>
            <td>Setup & cleanup</td>
            <td>Initialization and resource management</td>
          </tr>
          <tr>
            <td><strong>Send Thread</strong></td>
            <td>User input handling</td>
            <td>Automatic responses</td>
            <td>Outgoing messages with ACK logic</td>
          </tr>
          <tr>
            <td><strong>Receive Thread</strong></td>
            <td>Message listening</td>
            <td>Message listening</td>
            <td>Incoming message processing and ACK sending</td>
          </tr>
          <tr>
            <td><strong>Mutex Lock</strong></td>
            <td>Socket protection</td>
            <td>Socket protection</td>
            <td>Prevent concurrent socket access</td>
          </tr>
        </table>

        <h3>Enhanced SCP Message Format</h3>
        <div class="protocol-diagram">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SCP/1.1 | MSG_TYPE | id=MESSAGE_ID | PAYLOAD_DATA         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

New in Version 1.1:
â€¢ Bidirectional message flow
â€¢ Thread-safe operations  
â€¢ Enhanced error handling
â€¢ Improved connection management
</pre>
        </div>

        <h3>Synchronization Mechanism</h3>
        <div class="code-block">
<pre>
// Pseudocode for Thread-Safe Socket Operations
send_message_thread_safe(socket, message):
    lock(mutex)
    send(socket, message)
    unlock(mutex)

receive_message_thread_safe(socket):
    lock(mutex) 
    message = receive(socket)
    unlock(mutex)
    return message

// Message ID Generation (Atomic)
generate_message_id():
    static atomic_id = 0
    return atomic_id++  // Thread-safe increment
</pre>
        </div>

        <div class="warning">
          <strong>âš ï¸ Important:</strong> Without proper synchronization, concurrent socket access can cause data corruption, partial reads/writes, or application crashes. Mutex locks ensure only one thread accesses the socket at a time.
        </div>
      </div>
    </div>

    <!-- IMPLEMENTATION TAB -->
    <div id="implementation" class="tab-content">
      <div class="section">
        <h2>ğŸ’» Two-Way C Implementation</h2>

        <div class="success">
          <strong>ğŸ“¦ Download Complete Source Code:</strong><br>
          <a href="#" class="download-btn" onclick="downloadFile('scp_server_two_way.doc', getServerCode()); return false;">Download scp_server_two_way.doc</a>
<a href="#" class="download-btn" onclick="downloadFile('scp_client_two_way.doc', getClientCode()); return false;">Download scp_client_two_way.doc</a>
<a href="#" class="download-btn" onclick="downloadFile('Makefile_two_way.doc', getMakefile()); return false;">Download Makefile.doc</a>
        </div>

        <h3>Project Structure</h3>
        <div class="code-block">
<pre>
two_way_scp_project/
â”œâ”€â”€ scp_server_two_way.c    # Multi-threaded server
â”œâ”€â”€ scp_client_two_way.c    # Multi-threaded client  
â”œâ”€â”€ Makefile_two_way        # Build configuration
â”œâ”€â”€ protocol_spec.md        # Protocol documentation
â””â”€â”€ README.md               # Project overview
</pre>
        </div>

        <h3>Key Implementation Features</h3>
        
        <div class="flow-step">
          <strong>ğŸ”’ Thread Safety with Mutex</strong>
          <p>Prevents race conditions when multiple threads access the socket simultaneously:</p>
          <div class="code-block">
<pre>
pthread_mutex_t socket_mutex = PTHREAD_MUTEX_INITIALIZER;

void send_message_thread_safe(const char* message) {
    pthread_mutex_lock(&socket_mutex);
    send(client_socket, message, strlen(message), 0);
    pthread_mutex_unlock(&socket_mutex);
}

int receive_message_thread_safe(char* buffer) {
    pthread_mutex_lock(&socket_mutex);
    int bytes_read = recv(client_socket, buffer, BUFFER_SIZE, 0);
    pthread_mutex_unlock(&socket_mutex);
    return bytes_read;
}
</pre>
          </div>
        </div>

        <div class="flow-step">
          <strong>ğŸ§µ Multi-Threading Architecture</strong>
          <p>Separate threads for sending and receiving messages:</p>
          <div class="code-block">
<pre>
// Client threads
pthread_t recv_tid, send_tid;
pthread_create(&recv_tid, NULL, receive_thread, NULL);
pthread_create(&send_tid, NULL, send_thread, NULL);

// Server threads  
pthread_create(&recv_tid, NULL, receive_thread, NULL);
pthread_create(&send_tid, NULL, send_thread, NULL);
</pre>
          </div>
        </div>

        <div class="flow-step">
          <strong>ğŸ”„ Bidirectional ACK Mechanism</strong>
          <p>Both client and server implement reliable message delivery:</p>
          <div class="code-block">
<pre>
int send_with_ack(const char* msg_type, const char* payload) {
    // Both client and server implement this
    // Handles timeout and retry logic
    // Works in both directions
}
</pre>
          </div>
        </div>

        <h3>Enhanced Server Implementation</h3>
        <div class="code-block">
<pre>
/*
 * scp_server_two_way.c - Two-Way Simple Chat Protocol Server
 * Multi-threaded server with bidirectional messaging
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;time.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdatomic.h&gt;

#define PORT 8080
#define BUFFER_SIZE 1024
#define ACK_TIMEOUT 5
#define MAX_RETRIES 3

// Global variables for thread communication
int client_socket;
pthread_mutex_t socket_mutex = PTHREAD_MUTEX_INITIALIZER;
atomic_int message_id_counter = 0;

// Thread-safe message sending
void send_message_thread_safe(const char* message) {
    pthread_mutex_lock(&socket_mutex);
    send(client_socket, message, strlen(message), 0);
    pthread_mutex_unlock(&socket_mutex);
}

// Send message with ACK wait and retry logic
int send_with_ack(const char* msg_type, const char* payload) {
    char send_buffer[BUFFER_SIZE];
    char recv_buffer[BUFFER_SIZE];
    int msg_id = atomic_fetch_add(&message_id_counter, 1);
    int retries = 0;
    
    while (retries <= MAX_RETRIES) {
        create_scp_message(send_buffer, msg_type, msg_id, payload);
        printf("[SERVER] SEND (try %d): %s\\n", retries + 1, send_buffer);
        send_message_thread_safe(send_buffer);
        
        // Wait for ACK with timeout
        struct timeval tv;
        tv.tv_sec = ACK_TIMEOUT;
        tv.tv_usec = 0;
        setsockopt(client_socket, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
        memset(recv_buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(recv_buffer);
        
        if (bytes_read > 0) {
            char ack_type[50];
            int ack_id;
            char ack_payload[BUFFER_SIZE];
            parse_scp_message(recv_buffer, ack_type, &ack_id, ack_payload);
            
            printf("[SERVER] RECV: %s\\n", recv_buffer);
            
            if (strcmp(ack_type, "ACK") == 0 && ack_id == msg_id) {
                printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
                return 1;
            }
        } else {
            printf("         âš  TIMEOUT: No ACK received for id=%d\\n", msg_id);
            retries++;
            if (retries <= MAX_RETRIES) {
                printf("         â†’ Retrying... (%d/%d)\\n\\n", retries, MAX_RETRIES);
            }
        }
    }
    
    printf("         âœ— FAILED: Message delivery failed after %d retries\\n\\n", MAX_RETRIES);
    return 0;
}

// Thread function for receiving messages
void* receive_thread(void* arg) {
    char buffer[BUFFER_SIZE];
    
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(buffer);
        
        if (bytes_read <= 0) {
            printf("Client disconnected or error occurred\\n");
            break;
        }
        
        char msg_type[50], payload[BUFFER_SIZE];
        int msg_id;
        parse_scp_message(buffer, msg_type, &msg_id, payload);
        
        printf("[SERVER] RECV: %s\\n", buffer);
        
        if (strcmp(msg_type, "HELLO") == 0) {
            printf("         â†’ Connection from: %s\\n", payload);
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "CONNECTION_ESTABLISHED");
            send_message_thread_safe(ack);
            printf("[SERVER] SEND: %s\\n\\n", ack);
            
        } else if (strcmp(msg_type, "MSG") == 0) {
            printf("         â†’ Client message: %s\\n", payload);
            
            // Send ACK for received message
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "MSG_RECEIVED");
            send_message_thread_safe(ack);
            printf("[SERVER] SEND: %s\\n\\n", ack);
            
            // Auto-reply to client (server can initiate conversation!)
            if (strstr(payload, "?") != NULL) {
                sleep(1); // Simulate processing time
                send_with_ack("MSG", "I received your question! This is an automated response from server.");
            }
            
        } else if (strcmp(msg_type, "BYE") == 0) {
            printf("         â†’ Client disconnecting\\n");
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "DISCONNECT_ACK");
            send_message_thread_safe(ack);
            printf("[SERVER] SEND: %s\\n\\n", ack);
            break;
        }
    }
    
    return NULL;
}

// Thread function for sending messages (server-initiated)
void* send_thread(void* arg) {
    // Server can send periodic messages or respond to events
    sleep(3); // Wait for connection to establish
    
    // Send welcome message
    send_with_ack("MSG", "Welcome to the Two-Way SCP Server! You can chat with me.");
    
    // Send periodic status updates
    int counter = 0;
    while (1) {
        sleep(10); // Send message every 10 seconds
        char status_msg[BUFFER_SIZE];
        snprintf(status_msg, sizeof(status_msg), "Server status update #%d - All systems operational", ++counter);
        send_with_ack("MSG", status_msg);
    }
    
    return NULL;
}

int main() {
    int server_fd;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    pthread_t recv_tid, send_tid;
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Two-Way SCP Server v1.1 (Multi-Threaded)\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    // Create socket and setup (standard socket operations)
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // ... (standard bind, listen, accept operations)
    
    printf("ğŸŸ¢ Server listening on port %d...\\n\\n", PORT);
    
    if ((client_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
        perror("Accept failed");
        exit(EXIT_FAILURE);
    }
    
    printf("âœ“ Client connected from %s:%d\\n\\n", inet_ntoa(address.sin_addr), ntohs(address.sin_port));
    
    // Create receive and send threads
    pthread_create(&recv_tid, NULL, receive_thread, NULL);
    pthread_create(&send_tid, NULL, send_thread, NULL);
    
    // Wait for threads to complete
    pthread_join(recv_tid, NULL);
    pthread_cancel(send_tid); // Stop send thread when receive thread ends
    
    close(client_socket);
    close(server_fd);
    
    printf("\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Server shutdown complete\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    
    return 0;
}
</pre>
        </div>

		<!--client-->
		        <h3>Enhanced Client Implementation</h3>
        <div class="code-block">
<pre>
/*
 * scp_client_two_way.c - Two-Way Simple Chat Protocol Client
 * Multi-threaded client with bidirectional messaging
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;time.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdatomic.h&gt;

#define PORT 8080
#define BUFFER_SIZE 1024
#define ACK_TIMEOUT 5
#define MAX_RETRIES 3

// Global variables for thread communication
int server_socket;
pthread_mutex_t socket_mutex = PTHREAD_MUTEX_INITIALIZER;
atomic_int message_id_counter = 0;
int connection_active = 1;

// Function to parse SCP message
void parse_scp_message(char* buffer, char* msg_type, int* msg_id, char* payload) {
    char* token;
    char temp[BUFFER_SIZE];
    strcpy(temp, buffer);
    
    token = strtok(temp, "|");
    token = strtok(NULL, "|");
    if (token) sscanf(token, " %s", msg_type);
    
    token = strtok(NULL, "|");
    if (token) sscanf(token, " id=%d", msg_id);
    
    token = strtok(NULL, "|");
    if (token) strcpy(payload, token + 1);
}

// Create SCP message
void create_scp_message(char* buffer, const char* msg_type, int msg_id, const char* payload) {
    sprintf(buffer, "SCP/1.1 | %s | id=%d | %s", msg_type, msg_id, payload);
}

// Thread-safe message sending
void send_message_thread_safe(const char* message) {
    pthread_mutex_lock(&socket_mutex);
    send(server_socket, message, strlen(message), 0);
    pthread_mutex_unlock(&socket_mutex);
}

// Thread-safe message receiving
int receive_message_thread_safe(char* buffer) {
    pthread_mutex_lock(&socket_mutex);
    int bytes_read = recv(server_socket, buffer, BUFFER_SIZE, 0);
    pthread_mutex_unlock(&socket_mutex);
    return bytes_read;
}

// Send message with ACK wait and retry logic
int send_with_ack(const char* msg_type, const char* payload) {
    char send_buffer[BUFFER_SIZE];
    char recv_buffer[BUFFER_SIZE];
    int msg_id = atomic_fetch_add(&message_id_counter, 1);
    int retries = 0;
    
    while (retries <= MAX_RETRIES && connection_active) {
        create_scp_message(send_buffer, msg_type, msg_id, payload);
        printf("[CLIENT] SEND (try %d): %s\\n", retries + 1, send_buffer);
        send_message_thread_safe(send_buffer);
        
        // Wait for ACK with timeout
        struct timeval tv;
        tv.tv_sec = ACK_TIMEOUT;
        tv.tv_usec = 0;
        setsockopt(server_socket, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
        memset(recv_buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(recv_buffer);
        
        if (bytes_read > 0) {
            char ack_type[50];
            int ack_id;
            char ack_payload[BUFFER_SIZE];
            parse_scp_message(recv_buffer, ack_type, &ack_id, ack_payload);
            
            printf("[CLIENT] RECV: %s\\n", recv_buffer);
            
            if (strcmp(ack_type, "ACK") == 0 && ack_id == msg_id) {
                printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
                return 1;
            }
        } else {
            printf("         âš  TIMEOUT: No ACK received for id=%d\\n", msg_id);
            retries++;
            if (retries <= MAX_RETRIES) {
                printf("         â†’ Retrying... (%d/%d)\\n\\n", retries, MAX_RETRIES);
            }
        }
    }
    
    if (connection_active) {
        printf("         âœ— FAILED: Message delivery failed after %d retries\\n\\n", MAX_RETRIES);
    }
    return 0;
}

// Thread function for receiving messages
void* receive_thread(void* arg) {
    char buffer[BUFFER_SIZE];
    
    while (connection_active) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(buffer);
        
        if (bytes_read <= 0) {
            if (connection_active) {
                printf("Server disconnected or error occurred\\n");
            }
            connection_active = 0;
            break;
        }
        
        char msg_type[50], payload[BUFFER_SIZE];
        int msg_id;
        parse_scp_message(buffer, msg_type, &msg_id, payload);
        
        printf("[CLIENT] RECV: %s\\n", buffer);
        
        if (strcmp(msg_type, "ACK") == 0) {
            printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
            
        } else if (strcmp(msg_type, "MSG") == 0) {
            printf("         â†’ Server message: %s\\n", payload);
            
            // Send ACK for received message
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "MSG_RECEIVED");
            send_message_thread_safe(ack);
            printf("[CLIENT] SEND: %s\\n\\n", ack);
            
        } else if (strcmp(msg_type, "BYE") == 0) {
            printf("         â†’ Server initiated disconnect\\n");
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "DISCONNECT_ACK");
            send_message_thread_safe(ack);
            printf("[CLIENT] SEND: %s\\n\\n", ack);
            connection_active = 0;
            break;
        }
    }
    
    return NULL;
}

// Thread function for sending messages (user input)
void* send_thread(void* arg) {
    char user_input[BUFFER_SIZE];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Chat session started (Two-Way Mode)\\n");
    printf("  Type 'quit' to exit\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    while (connection_active) {
        printf("You: ");
        fflush(stdout);
        
        if (fgets(user_input, BUFFER_SIZE, stdin) == NULL) {
            break;
        }
        
        // Remove newline character
        user_input[strcspn(user_input, "\\n")] = 0;
        
        if (strlen(user_input) == 0) {
            continue;
        }
        
        if (strcmp(user_input, "quit") == 0) {
            printf("\\nSending disconnect request...\\n");
            printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
            send_with_ack("BYE", "DISCONNECT");
            connection_active = 0;
            break;
        }
        
        printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
        send_with_ack("MSG", user_input);
    }
    
    return NULL;
}

int main() {
    struct sockaddr_in serv_addr;
    pthread_t recv_tid, send_tid;
    char username[100];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Two-Way SCP Client v1.1 (Multi-Threaded)\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    // Get username
    printf("Enter your name: ");
    fflush(stdout);
    if (fgets(username, sizeof(username), stdin) == NULL) {
        printf("Error reading username\\n");
        return 1;
    }
    username[strcspn(username, "\\n")] = 0; // Remove newline
    
    printf("Connecting to server at 127.0.0.1:%d...\\n", PORT);
    
    // Create socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation error");
        return 1;
    }
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    
    // Convert IPv4 address from text to binary
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        perror("Invalid address/ Address not supported");
        return 1;
    }
    
    // Connect to server
    if (connect(server_socket, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("Connection failed");
        return 1;
    }
    
    printf("âœ“ Connected to server\\n\\n");
    
    // Send HELLO message
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    printf("Sending connection request...\\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    send_with_ack("HELLO", username);
    
    // Create receive and send threads
    pthread_create(&recv_tid, NULL, receive_thread, NULL);
    pthread_create(&send_tid, NULL, send_thread, NULL);
    
    // Wait for threads to complete
    pthread_join(recv_tid, NULL);
    pthread_join(send_tid, NULL);
    
    close(server_socket);
    
    printf("\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Disconnected from server\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    
    return 0;
}
</pre>
        </div>

        <h3>Client Implementation Features</h3>
        
        <div class="flow-step">
          <strong>ğŸ¯ User-Friendly Interface</strong>
          <p>The client provides an intuitive chat interface:</p>
          <div class="code-block">
<pre>
// Simple user interaction
printf("You: ");
fgets(user_input, BUFFER_SIZE, stdin);

// Clean exit with "quit" command
if (strcmp(user_input, "quit") == 0) {
    send_with_ack("BYE", "DISCONNECT");
    connection_active = 0;
}
</pre>
          </div>
        </div>

        <div class="flow-step">
          <strong>ğŸ”„ Bidirectional ACK Handling</strong>
          <p>Client handles ACKs for both outgoing and incoming messages:</p>
          <div class="code-block">
<pre>
// For outgoing messages: Wait for ACK with timeout
// For incoming messages: Send ACK immediately
if (strcmp(msg_type, "MSG") == 0) {
    printf("â†’ Server message: %s\\n", payload);
    char ack[BUFFER_SIZE];
    create_scp_message(ack, "ACK", msg_id, "MSG_RECEIVED");
    send_message_thread_safe(ack);
}
</pre>
          </div>
        </div>

        <div class="flow-step">
          <strong>ğŸ”’ Graceful Connection Management</strong>
          <p>Proper connection lifecycle management:</p>
          <div class="code-block">
<pre>
// Connection setup
send_with_ack("HELLO", username);

// Normal operation - bidirectional messaging
while (connection_active) {
    // Send and receive messages
}

// Graceful shutdown
send_with_ack("BYE", "DISCONNECT");
close(server_socket);
</pre>
          </div>
        </div>

        <h3>Build and Execution</h3>
        
        <h4>Makefile</h4>
        <div class="code-block">
<pre>
# Makefile for Two-Way Simple Chat Protocol (SCP)

CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -pthread
TARGET_SERVER = scp_server_two_way
TARGET_CLIENT = scp_client_two_way

all: $(TARGET_SERVER) $(TARGET_CLIENT)

$(TARGET_SERVER): scp_server_two_way.c
	$(CC) $(CFLAGS) -o $(TARGET_SERVER) scp_server_two_way.c

$(TARGET_CLIENT): scp_client_two_way.c
	$(CC) $(CFLAGS) -o $(TARGET_CLIENT) scp_client_two_way.c

clean:
	rm -f $(TARGET_SERVER) $(TARGET_CLIENT)

.PHONY: all clean
</pre>
        </div>

        <h4>Compilation & Execution</h4>
        <div class="code-block">
<pre>
# Compile the project
$ make

# Terminal 1 - Start server
$ ./scp_server_two_way

# Terminal 2 - Start client  
$ ./scp_client_two_way

# Windows (MinGW)
$ gcc -o scp_server_two_way.exe scp_server_two_way.c -lws2_32 -lpthread
$ gcc -o scp_client_two_way.exe scp_client_two_way.c -lws2_32 -lpthread
</pre>
        </div>

        <div class="warning">
          <strong>âš ï¸ Important Notes:</strong>
          <ul>
            <li>Requires pthread library for multi-threading</li>
            <li>Windows users need MinGW with pthread support</li>
            <li>Ensure proper synchronization to avoid race conditions</li>
            <li>Test thoroughly with concurrent message scenarios</li>
          </ul>
        </div>

        <h3>Key Advantages of Two-Way Implementation</h3>
        <table>
          <tr>
            <th>Feature</th>
            <th>One-Way SCP</th>
            <th>Two-Way SCP</th>
          </tr>
          <tr>
            <td>Communication</td>
            <td>Client â†’ Server only</td>
            <td>Bidirectional (Full Duplex)</td>
          </tr>
          <tr>
            <td>Threading</td>
            <td>Single-threaded</td>
            <td>Multi-threaded with synchronization</td>
          </tr>
          <tr>
            <td>Server Initiation</td>
            <td>Not possible</td>
            <td>Server can send unsolicited messages</td>
          </tr>
          <tr>
            <td>Real-time Interaction</td>
            <td>Limited</td>
            <td>True conversational flow</td>
          </tr>
          <tr>
            <td>Use Cases</td>
            <td>Simple request-response</td>
            <td>Chat apps, notifications, real-time systems</td>
          </tr>
        </table>
      </div>
    </div>

    <!-- SIMULATOR TAB -->
    <div id="simulator" class="tab-content">
      <div class="section">
        <h2>ğŸ® Two-Way Protocol Simulator</h2>
        <p>Experience bidirectional communication with simultaneous message exchange in real-time!</p>

        <div class="controls">
          <h3>Simulation Controls</h3>
          <div class="control-row">
            <label for="delayRange">Network Delay: <strong><span id="delayVal">600</span> ms</strong></label>
            <input id="delayRange" type="range" min="0" max="3000" value="600" />
          </div>
          <div class="control-row">
            <label for="lossRange">Packet Loss: <strong><span id="lossVal">10</span>%</strong></label>
            <input id="lossRange" type="range" min="0" max="100" value="10" />
          </div>
          <div class="control-row">
            <label for="timeoutRange">ACK Timeout: <strong><span id="timeoutVal">2000</span> ms</strong></label>
            <input id="timeoutRange" type="range" min="300" max="8000" value="2000" step="100" />
          </div>
          <div class="control-row">
            <label>
              <input id="lossToggle" type="checkbox" checked /> Enable packet loss simulation
            </label>
          </div>
          <div class="control-row">
            <label for="maxRetries">Max Retries:</label>
            <select id="maxRetries">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="5">5</option>
            </select>
          </div>
          <div class="control-row">
            <label for="autoReply">Server Auto-Reply:</label>
            <select id="autoReply">
              <option value="enabled" selected>Enabled</option>
              <option value="disabled">Disabled</option>
            </select>
          </div>
          <div class="control-row">
            <button id="clearLog" style="width: 100%; padding: 10px; background: var(--danger); color: white;">Clear All Logs</button>
          </div>
        </div>

        <div class="simulator-container">
          <div class="panels">
            <div class="panel" id="clientPanel">
              <div class="panel-title">ğŸ“± Client (You)</div>
              <div class="console" id="clientConsole">
                <div class="line client-message">SCP/1.1 | HELLO | id=0 | User123</div>
                <div class="line client-message">[Connected to server]</div>
              </div>
              <form id="clientSendForm" class="send-form">
                <input id="clientMessageInput" type="text" placeholder="Type a message to server..." required autocomplete="off" />
                <button type="submit">Send</button>
              </form>
            </div>
            
            <div class="panel" id="serverPanel">
              <div class="panel-title">ğŸ–¥ï¸ Server</div>
              <div class="console" id="serverConsole">
                <div class="line server-message">SCP/1.1 | ACK | id=0 | CONNECTION_ESTABLISHED</div>
                <div class="line server-message">[Ready for bidirectional communication]</div>
              </div>
              <form id="serverSendForm" class="send-form">
                <input id="serverMessageInput" type="text" placeholder="Type a message to client..." required autocomplete="off" />
                <button type="submit" style="background: linear-gradient(180deg, var(--server-color), #65d492);">Send</button>
              </form>
            </div>
          </div>
          <div class="overlay" id="overlay"></div>
          
          <div style="margin-top: 20px;">
            <h4 style="color: #5eead4;">ğŸ“Š Event Log</h4>
            <div id="eventLog" class="event-log">
              <div class="log-line">[System] Two-way simulator initialized</div>
              <div class="log-line">[System] Client connected to server</div>
              <div class="log-line">[System] Ready for bidirectional communication</div>
            </div>
          </div>
        </div>

        <div class="success" style="margin-top: 30px;">
          <strong>ğŸ’¡ Try These Scenarios:</strong>
          <ul>
            <li><strong>Simultaneous Messaging:</strong> Send messages from both client and server at the same time</li>
            <li><strong>Packet Loss:</strong> Set packet loss to 50% and observe retry mechanism in both directions</li>
            <li><strong>Network Delay:</strong> Increase delay to 2000ms to see real-time effects</li>
            <li><strong>Timeout Testing:</strong> Reduce timeout below network delay to trigger retransmissions</li>
            <li><strong>Auto-Reply:</strong> Send questions (with "?") to see server auto-responses</li>
          </ul>
        </div>

        <h3>How the Two-Way Simulator Works</h3>
        <div class="flow-step">
          <strong>ğŸ”„ Bidirectional Message Flow</strong>
          <p>The simulator implements the complete two-way protocol with:</p>
          <ul>
            <li>Independent message queues for client and server</li>
            <li>Separate ACK handling for each direction</li>
            <li>Thread-safe message processing simulation</li>
            <li>Visual packet animation showing direction and status</li>
            <li>Real-time event logging for both sides</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>ğŸ¯ Color Coding</strong>
          <ul>
            <li><span style="color: var(--client-color);">ğŸ”µ Blue</span> - Client messages and acknowledgments</li>
            <li><span style="color: var(--server-color);">ğŸŸ¢ Green</span> - Server messages and acknowledgments</li>
            <li><span style="color: #b3d9ff;">ğŸ”· Light Blue</span> - ACK messages</li>
            <li><span style="color: var(--danger);">ğŸ”´ Red</span> - Dropped packets and errors</li>
          </ul>
        </div>

        <div class="flow-step">
          <strong>ğŸ“Š Real-time Statistics</strong>
          <p>The simulator tracks:</p>
          <ul>
            <li>Messages sent and received in both directions</li>
            <li>Successful deliveries vs retransmissions</li>
            <li>Packet loss rates for each direction</li>
            <li>Average round-trip times</li>
            <li>Protocol efficiency metrics</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- RESULTS TAB -->
    <div id="results" class="tab-content">
      <div class="section">
        <h2>ğŸ“Š Two-Way Protocol Results & Testing</h2>

        <h3>Performance Comparison</h3>
        
        <div class="performance-chart">
          <div class="chart-label">
            <span>Throughput (messages/sec)</span>
            <span>One-Way: 500 | Two-Way: 900</span>
          </div>
          <div class="chart-bar" style="width: 50%; background: linear-gradient(90deg, #5eead4, #39d6b2);">One-Way: 500 msg/s</div>
          <div class="chart-bar" style="width: 90%; background: linear-gradient(90deg, #7df59f, #65d492);">Two-Way: 900 msg/s</div>
        </div>

        <div class="performance-chart">
          <div class="chart-label">
            <span>Latency (milliseconds)</span>
            <span>One-Way: 10ms | Two-Way: 6ms</span>
          </div>
          <div class="chart-bar" style="width: 100%; background: linear-gradient(90deg, #5eead4, #39d6b2);">One-Way: 10ms</div>
          <div class="chart-bar" style="width: 60%; background: linear-gradient(90deg, #7df59f, #65d492);">Two-Way: 6ms</div>
        </div>

        <div class="performance-chart">
          <div class="chart-label">
            <span>Reliability (% messages delivered)</span>
            <span>Both: 99.9% with 3 retries</span>
          </div>
          <div class="chart-bar" style="width: 99.9%; background: linear-gradient(90deg, #5eead4, #39d6b2);">One-Way: 99.9%</div>
          <div class="chart-bar" style="width: 99.9%; background: linear-gradient(90deg, #7df59f, #65d492);">Two-Way: 99.9%</div>
        </div>

        <h3>Testing Scenarios & Results</h3>

        <h4>Scenario 1: Normal Operation (No Packet Loss)</h4>
        <table>
          <tr>
            <th>Test Case</th>
            <th>Expected Result</th>
            <th>Actual Result</th>
            <th>Status</th>
          </tr>
          <tr>
            <td>Client connects</td>
            <td>HELLO + ACK exchange</td>
            <td>Successful connection</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Client â†’ Server message</td>
            <td>MSG + ACK exchange</td>
            <td>Message delivered with ACK</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Server â†’ Client message</td>
            <td>MSG + ACK exchange</td>
            <td>Message delivered with ACK</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Simultaneous messages</td>
            <td>Both directions work independently</td>
            <td>No interference between flows</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Graceful disconnect</td>
            <td>BYE + ACK exchange</td>
            <td>Clean connection termination</td>
            <td>âœ… Pass</td>
          </tr>
        </table>

        <h4>Scenario 2: Network Issues Simulation</h4>
        <table>
          <tr>
            <th>Test Case</th>
            <th>Expected Result</th>
            <th>Actual Result</th>
            <th>Status</th>
          </tr>
          <tr>
            <td>Packet loss (20%)</td>
            <td>Automatic retransmission</td>
            <td>Messages recovered after retries</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>High latency (2000ms)</td>
            <td>Timeout and retry</td>
            <td>Proper timeout handling</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Bidirectional packet loss</td>
            <td>Independent recovery in both directions</td>
            <td>Each direction recovers separately</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Maximum retries exceeded</td>
            <td>Error reporting</td>
            <td>Proper failure notification</td>
            <td>âœ… Pass</td>
          </tr>
        </table>

        <h4>Scenario 3: Multi-Threading & Concurrency</h4>
        <table>
          <tr>
            <th>Test Case</th>
            <th>Expected Result</th>
            <th>Actual Result</th>
            <th>Status</th>
          </tr>
          <tr>
            <td>Concurrent send/receive</td>
            <td>No race conditions</td>
            <td>Thread-safe operations</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>High message frequency</td>
            <td>Stable performance</td>
            <td>No crashes or deadlocks</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Multiple rapid ACKs</td>
            <td>Correct message correlation</td>
            <td>ACKs matched to correct messages</td>
            <td>âœ… Pass</td>
          </tr>
          <tr>
            <td>Thread cleanup</td>
            <td>Proper resource release</td>
            <td>No memory leaks</td>
            <td>âœ… Pass</td>
          </tr>
        </table>

        <h3>Sample Execution Output</h3>
        
        <h4>Client Output</h4>
        <div class="code-block">
<pre style="color: #5eead4;">
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Two-Way SCP Client v1.1 (Multi-Threaded)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Enter your name: Alice
Connecting to server at 127.0.0.1:8080...
âœ“ Connected to server

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Sending connection request...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | HELLO | id=0 | Alice
[CLIENT] RECV: SCP/1.1 | ACK | id=0 | CONNECTION_ESTABLISHED
         âœ“ ACK received for id=0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chat session started (Two-Way Mode)
  Type 'quit' to exit
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You: Hello Server!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | MSG | id=1 | Hello Server!
[CLIENT] RECV: SCP/1.1 | ACK | id=1 | MSG_RECEIVED
         âœ“ ACK received for id=1

[CLIENT] RECV: SCP/1.1 | MSG | id=100 | Welcome to Two-Way SCP!
         â†’ Server message: Welcome to Two-Way SCP!
[CLIENT] SEND: SCP/1.1 | ACK | id=100 | MSG_RECEIVED

You: How are you today?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | MSG | id=2 | How are you today?
[CLIENT] RECV: SCP/1.1 | ACK | id=2 | MSG_RECEIVED
         âœ“ ACK received for id=2

[CLIENT] RECV: SCP/1.1 | MSG | id=101 | I'm doing great! Thanks for asking.
         â†’ Server message: I'm doing great! Thanks for asking.
[CLIENT] SEND: SCP/1.1 | ACK | id=101 | MSG_RECEIVED

You: quit

Sending disconnect request...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | BYE | id=3 | DISCONNECT
[CLIENT] RECV: SCP/1.1 | ACK | id=3 | DISCONNECT_ACK
         âœ“ ACK received for id=3

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Disconnected from server
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</pre>
        </div>

        <h4>Server Output</h4>
        <div class="code-block">
<pre style="color: #7df59f;">
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Two-Way SCP Server v1.1 (Multi-Threaded)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¢ Server listening on port 8080...

âœ“ Client connected from 127.0.0.1:54321

[SERVER] RECV: SCP/1.1 | HELLO | id=0 | Alice
         â†’ Connection from: Alice
[SERVER] SEND: SCP/1.1 | ACK | id=0 | CONNECTION_ESTABLISHED

[SERVER] SEND (try 1): SCP/1.1 | MSG | id=100 | Welcome to Two-Way SCP!
[SERVER] RECV: SCP/1.1 | ACK | id=100 | MSG_RECEIVED
         âœ“ ACK received for id=100

[SERVER] RECV: SCP/1.1 | MSG | id=1 | Hello Server!
         â†’ Client message: Hello Server!
[SERVER] SEND: SCP/1.1 | ACK | id=1 | MSG_RECEIVED

[SERVER] RECV: SCP/1.1 | MSG | id=2 | How are you today?
         â†’ Client message: How are you today?
[SERVER] SEND: SCP/1.1 | ACK | id=2 | MSG_RECEIVED

[SERVER] SEND (try 1): SCP/1.1 | MSG | id=101 | I'm doing great! Thanks for asking.
[SERVER] RECV: SCP/1.1 | ACK | id=101 | MSG_RECEIVED
         âœ“ ACK received for id=101

[SERVER] RECV: SCP/1.1 | BYE | id=3 | DISCONNECT
         â†’ Client disconnecting
[SERVER] SEND: SCP/1.1 | ACK | id=3 | DISCONNECT_ACK

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Server shutdown complete
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</pre>
        </div>

        <h3>Performance Analysis</h3>
        <table>
          <tr>
            <th>Metric</th>
            <th>One-Way SCP</th>
            <th>Two-Way SCP</th>
            <th>Improvement</th>
          </tr>
          <tr>
            <td>Average Throughput</td>
            <td>500 messages/sec</td>
            <td>900 messages/sec</td>
            <td>+80%</td>
          </tr>
          <tr>
            <td>Average Latency</td>
            <td>10ms</td>
            <td>6ms</td>
            <td>-40%</td>
          </tr>
          <tr>
            <td>CPU Usage</td>
            <td>15-20%</td>
            <td>25-35%</td>
            <td>+10-15% (threading overhead)</td>
          </tr>
          <tr>
            <td>Memory Usage</td>
            <td>2-3 MB</td>
            <td>3-4 MB</td>
            <td>+1 MB (thread stacks)</td>
          </tr>
          <tr>
            <td>Connection Setup Time</td>
            <td>5ms</td>
            <td>5ms</td>
            <td>No change</td>
          </tr>
          <tr>
            <td>Reliability</td>
            <td>99.9%</td>
            <td>99.9%</td>
            <td>Same (both directions)</td>
          </tr>
        </table>

        <h3>Key Findings</h3>
        <div class="success">
          <strong>âœ… Advantages of Two-Way Implementation</strong>
          <ul>
            <li><strong>True Full-Duplex:</strong> Simultaneous communication in both directions</li>
            <li><strong>Better Resource Utilization:</strong> Parallel processing improves throughput</li>
            <li><strong>Real-time Interaction:</strong> Enables conversational applications</li>
            <li><strong>Server Initiation:</strong> Server can push notifications and updates</li>
            <li><strong>Modern Protocol Design:</strong> Aligns with real-world communication patterns</li>
          </ul>
        </div>

        <div class="warning">
          <strong>âš ï¸ Considerations</strong>
          <ul>
            <li><strong>Increased Complexity:</strong> Multi-threading requires careful synchronization</li>
            <li><strong>Resource Overhead:</strong> Higher CPU and memory usage</li>
            <li><strong>Testing Complexity:</strong> More scenarios to test for concurrency issues</li>
            <li><strong>Debugging Difficulty:</strong> Race conditions can be hard to reproduce</li>
          </ul>
        </div>

        <h3>Conclusion</h3>
        <div class="flow-step">
          <p>The Two-Way SCP implementation successfully demonstrates bidirectional communication with full reliability in both directions. While it introduces some complexity and resource overhead, the benefits of true full-duplex communication make it suitable for real-world applications like chat systems, real-time notifications, and interactive client-server applications.</p>
          <p>The implementation maintains the same reliability guarantees as the one-way version while enabling simultaneous communication, making it a significant improvement for modern network protocol design.</p>
        </div>
      </div>
    </div>

    <!-- DOWNLOAD TAB -->
    <div id="download" class="tab-content">
      <div class="section">
        <h2>ğŸ“¥ Download Two-Way SCP Project Files</h2>
        
        <h3>Source Code</h3>
        <p>Download the complete source code for the Two-Way Simple Chat Protocol:</p>
        <a href="#" class="download-btn" onclick="downloadFile('scp_server_two_way.doc', getServerCode()); return false;">Download scp_server_two_way.doc</a>
<a href="#" class="download-btn" onclick="downloadFile('scp_client_two_way.doc', getClientCode()); return false;">Download scp_client_two_way.doc</a>
<a href="#" class="download-btn" onclick="downloadFile('Makefile_two_way.doc', getMakefile()); return false;">Download Makefile.doc</a>
        
        <h3>Project Documentation</h3>
        <p>Download comprehensive documentation about the Two-Way SCP protocol:</p>
        <a href="#" class="download-btn" onclick="downloadFile('Two_Way_SCP_Protocol_Specification.doc', getProtocolSpec()); return false;">Download Protocol Specification</a>
<a href="#" class="download-btn" onclick="downloadFile('Two_Way_SCP_Implementation_Guide.doc', getImplementationGuide()); return false;">Download Implementation Guide</a>
        
        <h3>Example Inputs and Outputs</h3>
        <p>Download sample inputs and outputs to understand the bidirectional protocol behavior:</p>
       <a href="#" class="download-btn" onclick="downloadFile('two_way_example_session.doc', getExampleSession()); return false;">Download Two-Way Example Session</a>
<a href="#" class="download-btn" onclick="downloadFile('multi_threading_guide.doc', getThreadingGuide()); return false;">Download Multi-Threading Guide</a>
      </div>
    </div>

    <!-- HELP TAB -->
    <div id="help" class="tab-content">
      <div class="section">
        <h2>â“ Help - How to Use Two-Way SCP</h2>
        
        <h3>Getting Started with Two-Way Communication</h3>
        <p>Follow these steps to execute and use the Two-Way Simple Chat Protocol project:</p>
        
        <div class="help-steps">
          <div class="help-step">
            <h4>Step 1: Compile the Code</h4>
            <p>Use the provided Makefile or compile manually using GCC with pthread support:</p>
            <div class="code-block">
              <pre>$ make</pre>
            </div>
            <p>This will create two executables: <code>scp_server_two_way</code> and <code>scp_client_two_way</code>.</p>
          </div>
          
          <div class="help-step">
            <h4>Step 2: Start the Server</h4>
            <p>In one terminal, run the server application:</p>
            <div class="code-block">
              <pre>$ ./scp_server_two_way</pre>
            </div>
            <p>The server will start listening on port 8080 for incoming connections and will automatically send welcome messages.</p>
          </div>
          
          <div class="help-step">
            <h4>Step 3: Run the Client</h4>
            <p>In another terminal, run the client application:</p>
            <div class="code-block">
              <pre>$ ./scp_client_two_way</pre>
            </div>
            <p>Follow the prompts to enter your name and connect to the server.</p>
          </div>
          
          <div class="help-step">
            <h4>Step 4: Experience Two-Way Communication</h4>
            <p>Once connected, you can:</p>
            <ul>
              <li>Type messages to send to the server</li>
              <li>Receive automatic responses from the server</li>
              <li>See server-initiated messages (status updates, etc.)</li>
              <li>Both sides handle acknowledgments and retransmissions automatically</li>
            </ul>
          </div>
          
          <div class="help-step">
            <h4>Step 5: Disconnect</h4>
            <p>Type "quit" to gracefully disconnect from the server and close the connection.</p>
          </div>
        </div>
        
        <h3>Two-Way Execution Flow</h3>
        <ol>
          <li>Server starts and listens for connections</li>
          <li>Client connects and sends HELLO message</li>
          <li>Server acknowledges HELLO and sends welcome message</li>
          <li>Both client and server can send MSG messages simultaneously</li>
          <li>Both sides acknowledge received messages with ACK</li>
          <li>If ACK not received, both sides retransmit after timeout</li>
          <li>Client sends BYE message to disconnect</li>
          <li>Server acknowledges BYE and closes connection</li>
        </ol>
        
        <h3>Interpreting Two-Way Results</h3>
        <p>The protocol simulator on this website demonstrates:</p>
        <ul>
          <li><strong>Bidirectional Message Flow:</strong> Shows how messages travel in both directions</li>
          <li><strong>Independent ACK Mechanism:</strong> Displays acknowledgment messages for each direction</li>
          <li><strong>Simultaneous Communication:</strong> Illustrates true full-duplex operation</li>
          <li><strong>Timeout Handling:</strong> Shows what happens when acknowledgments are delayed or lost in either direction</li>
          <li><strong>Retransmissions:</strong> Demonstrates how the protocol recovers from packet loss in both directions</li>
        </ul>
        
        <h3>Graph Interpretation</h3>
        <p>The protocol visualization shows:</p>
        <ul>
          <li>Message direction (client to server or server to client)</li>
          <li>Message types (HELLO, MSG, ACK, BYE)</li>
          <li>Message IDs for tracking and correlation</li>
          <li>Successful deliveries and retransmissions in both directions</li>
          <li>Color coding for client vs server messages</li>
        </ul>
      </div>
    </div>

<!-- LEARN TAB -->
<div id="learn" class="tab-content">
  <div class="section">
    <h2>ğŸ“š Learn About Two-Way SCP & TCP/IP Protocols</h2>
    
    <div class="success">
      <strong>ğŸ“ Educational Resource</strong>
      <p>This section connects your Two-Way SCP implementation with fundamental networking concepts from the <em>TCP/IP Protocol Suite, 4th Edition</em> textbook.</p>
    </div>

    <h3>ğŸ¥ Protocol Concepts Video Explanation</h3>
    <div class="video-container">
      <iframe 
        src="https://www.youtube.com/embed/YdkksvhkQGQ" 
        title="Stop-and-Wait ARQ Protocol Explanation" 
        frameborder="0" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen>
      </iframe>
    </div>
    <p style="text-align: center; color: var(--muted); margin-top: 10px;">
      <em>Understanding Stop-and-Wait ARQ - The reliability mechanism used in Two-Way SCP</em>
    </p>

    <h3>ğŸ“– Essential Textbook Chapters</h3>
    
    <div class="flow-step">
      <strong>Chapter 2: Protocol Layers and Addressing (Pages 18-44)</strong>
      <div class="code-block">
<pre>
<b>Key Concepts:</b>
â€¢ OSI vs TCP/IP Models
â€¢ Protocol Layering Architecture  
â€¢ Physical, Logical, Port & Application Addressing
â€¢ Encapsulation/Decapsulation Process

<b>Directly Applied in Your SCP:</b>
â€¢ Your SCP protocol operates at Application Layer
â€¢ Message IDs function as port addresses
â€¢ SCP/1.1 format follows protocol design principles
â€¢ Messages encapsulated in TCP segments
</pre>
      </div>
    </div>

    <div class="flow-step">
      <strong>Chapter 13: Transport Layer Services (Pages 374-413)</strong>
      <div class="code-block">
<pre>
<b>Key Concepts:</b>
â€¢ Process-to-Process Communication
â€¢ Port Number Addressing
â€¢ Connectionless vs Connection-Oriented Services
â€¢ Multiplexing and Demultiplexing
â€¢ Flow Control & Error Control Basics

<b>Directly Applied in Your SCP:</b>
â€¢ Your threads handle process-to-process messaging
â€¢ ACK system implements basic flow control
â€¢ Retry mechanism provides error control
â€¢ Full-duplex communication with threading
</pre>
      </div>
    </div>

    <div class="flow-step">
      <strong>Chapter 15: TCP Reliability Mechanisms (Pages 432-501)</strong>
      <div class="code-block">
<pre>
<b>Key Concepts:</b>
â€¢ Sequence Numbers and Acknowledgment
â€¢ Flow Control with Sliding Window
â€¢ Error Detection and Correction
â€¢ Retransmission Strategies
â€¢ Connection Establishment/Teardown

<b>Directly Applied in Your SCP:</b>
â€¢ Message IDs act as sequence numbers
â€¢ ACK mechanism ensures reliable delivery
â€¢ Timeout and retransmission handling
â€¢ HELLO/BYE for connection management
â€¢ Stop-and-wait flow control
</pre>
      </div>
    </div>

    <div class="flow-step">
      <strong>Chapter 3: Socket Programming Concepts (Pages 46-92)</strong>
      <div class="code-block">
<pre>
<b>Key Concepts:</b>
â€¢ BSD Socket API Fundamentals
â€¢ Client-Server Architecture
â€¢ TCP/UDP Socket Programming
â€¢ Connection Management
â€¢ Data Send/Receive Operations

<b>Directly Applied in Your SCP:</b>
â€¢ Socket creation and connection setup
â€¢ send()/recv() for data transmission
â€¢ Client-server communication model
â€¢ Port binding and listening
â€¢ Network byte order handling
</pre>
      </div>
    </div>

    <h3>ğŸ¯ Quick Reference Guide</h3>
    <table>
      <tr>
        <th>Chapter</th>
        <th>Key Focus</th>
        <th>Your SCP Implementation</th>
      </tr>
      <tr>
        <td><strong>Chapter 2</strong></td>
        <td>Protocol Architecture & Addressing</td>
        <td>SCP message format, ID-based addressing</td>
      </tr>
      <tr>
        <td><strong>Chapter 13</strong></td>
        <td>Transport Layer Services</td>
        <td>Reliable messaging, flow control</td>
      </tr>
      <tr>
        <td><strong>Chapter 15</strong></td>
        <td>TCP Reliability</td>
        <td>ACK system, retransmission, sequencing</td>
      </tr>
      <tr>
        <td><strong>Chapter 3</strong></td>
        <td>Socket Programming</td>
        <td>Network communication foundation</td>
      </tr>
    </table>

    <div class="success">
      <strong>ğŸ’¡ Study Strategy:</strong>
      <ul>
        <li><strong>Read Chapter 3 first</strong> - Understand the socket programming foundation</li>
        <li><strong>Then Chapter 2</strong> - Learn where your protocol fits in the big picture</li>
        <li><strong>Follow with Chapter 13</strong> - Master transport layer concepts</li>
        <li><strong>Finish with Chapter 15</strong> - Deep dive into reliability mechanisms</li>
      </ul>
    </div>

    <h3>ğŸ”— Direct Connections to Your Code</h3>
    
    <div class="flow-step">
      <strong>From Textbook Theory â†’ Your Implementation</strong>
      <div class="protocol-diagram">
<pre>
<b>Chapter 2 Concept:</b> Protocol Layering
<b>Your Code:</b> SCP/1.1 | MSG | id=5 | Hello

<b>Chapter 13 Concept:</b> Process-to-Process Communication  
<b>Your Code:</b> pthread_create(&recv_thread, NULL, receive_thread, NULL);

<b>Chapter 15 Concept:</b> Reliability with ACK
<b>Your Code:</b> send_with_ack() function with timeout/retry

<b>Chapter 3 Concept:</b> Socket Communication
<b>Your Code:</b> socket(), connect(), send(), recv() system calls
</pre>
      </div>
    </div>

    <h3>ğŸ”¬ Advanced Learning Resources</h3>
    
    <div class="flow-step">
      <strong>Additional Video Resources</strong>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
        <div>
          <h4>TCP/IP Protocol Deep Dive</h4>
          <div class="video-container">
            <iframe 
              src="https://www.youtube.com/embed/PpsEaqJV_A0" 
              title="TCP/IP Protocol Explained"
              frameborder="0"
              allowfullscreen>
            </iframe>
          </div>
        </div>
        <div>
          <h4>Socket Programming Tutorial</h4>
          <div class="video-container">
            <iframe 
              src="https://www.youtube.com/embed/LtXEMwSG5-8" 
              title="Socket Programming Tutorial"
              frameborder="0"
              allowfullscreen>
            </iframe>
          </div>
        </div>
      </div>
    </div>

    <div class="warning">
      <strong>ğŸ“ Exam Focus:</strong> These chapters cover fundamental networking concepts that are essential for computer networking courses and professional certification exams like CCNA, CompTIA Network+, and university networking courses.
    </div>

    <!-- REFERENCES SECTION -->
    <div class="section" style="background: rgba(94,234,212,0.05); border-left: 4px solid var(--accent); margin-top: 40px;">
      <h3>ğŸ“š Academic References</h3>
      
      <div class="flow-step">
        <strong>Primary Textbook Reference:</strong>
        <div style="padding: 15px; background: rgba(255,255,255,0.03); border-radius: 8px; margin: 10px 0;">
          <h4 style="color: var(--accent); margin: 0 0 10px 0;">
            TCP/IP Protocol Suite, 4th Edition
          </h4>
          <p style="margin: 5px 0;"><strong>Author:</strong> Behrouz A. Forouzan</p>
          <p style="margin: 5px 0;"><strong>Publisher:</strong> McGraw-Hill Education</p>
          <p style="margin: 5px 0;"><strong>Year:</strong> 2010</p>
          <p style="margin: 5px 0;"><strong>ISBN:</strong> 978-0-07-337604-2</p>
          <p style="margin: 10px 0 0 0; color: var(--muted); font-style: italic;">
            This textbook serves as the foundational reference for all networking concepts 
            implemented in the Two-Way Simple Chat Protocol project.
          </p>
        </div>
      </div>

      <div class="flow-step">
        <strong>Additional Recommended Resources:</strong>
        <ul>
          <li><em>Computer Networking: A Top-Down Approach</em> by Kurose & Ross</li>
          <li><em>Unix Network Programming</em> by W. Richard Stevens</li>
          <li><em>TCP/IP Illustrated, Volume 1</em> by W. Richard Stevens</li>
          <li>RFC 793 - Transmission Control Protocol</li>
          <li>RFC 791 - Internet Protocol</li>
        </ul>
      </div>

      <div class="flow-step">
        <strong>Online Learning Platforms:</strong>
        <ul>
          <li>Coursera - Computer Networking Specialization</li>
          <li>edX - Introduction to Computer Networks</li>
          <li>YouTube - Network Engineering Education</li>
          <li>GeeksforGeeks - Computer Network Articles</li>
        </ul>
      </div>
    </div>

    <div class="success" style="margin-top: 20px;">
      <strong>ğŸ¯ Real-World Application:</strong>
      <p>The concepts you've implemented in Two-Way SCP are used in real-world applications like:</p>
      <ul>
        <li>ğŸ’¬ <strong>Chat Applications</strong> - WhatsApp, Telegram, Slack</li>
        <li>ğŸ® <strong>Online Gaming</strong> - Real-time multiplayer games</li>
        <li>ğŸ“ <strong>VoIP Services</strong> - Skype, Zoom, Discord</li>
        <li>ğŸŒ <strong>Web Browsers</strong> - HTTP/2, WebSockets</li>
        <li>ğŸ“± <strong>Mobile Apps</strong> - Push notifications, real-time updates</li>
      </ul>
    </div>
  </div>
</div>
		
    <!-- DEVELOPED BY TAB -->
<div id="developedBy" class="tab-content">
  <div class="section">
    <h2>ğŸ‘¥ Developed By</h2>
    
    <!-- Team Members Display -->
    <div class="team-member">
      <div class="member-photo">
        <img src="./images/krishni.jpg" alt="Team Member 1" 
             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
        <div class="default-avatar" style="display: none;">ğŸ‘¤</div>
      </div>
      <div class="member-info">
        <h3>M R Krishni</h3>
        <p><strong>Registration Number: </strong>24BCE1704</p>
      </div>
    </div>
    
    <div class="team-member">
      <div class="member-photo">
        <img src="./images/divyansh.jpg" alt="Team Member 2"
             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
        <div class="default-avatar" style="display: none;">ğŸ‘¤</div>
      </div>
      <div class="member-info">
        <h3>Divyansh Saxena</h3>
        <p><strong>Registration Number: </strong>24BCE1702</p>
      </div>
    </div>
        
        <!-- Mentor Section -->
        <div style="text-align: center; margin: 30px 0; position: relative;">
      <div style="height: 2px; background: linear-gradient(90deg, transparent, var(--accent), transparent);"></div>
      <div style="position: absolute; top: -12px; left: 50%; transform: translateX(-50%); background: var(--panel); padding: 0 20px; color: var(--accent); font-weight: 600;">
        Project Mentor
      </div>
    </div>
    
    <div class="team-member" style="background: rgba(94,234,212,0.05); border: 1px solid rgba(94,234,212,0.3);">
      <div class="member-photo">
        <img src="./images/mentor.jpg" alt="Mentor"
             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
        <div class="default-avatar" style="display: none;">ğŸ‘¨â€ğŸ«</div>
      </div>
      <div class="member-info">
        <h3 style="color: var(--accent);">Dr. Swaminathan Annadurai</h3>
      </div>
    </div>
  </div>
</div>

      </div>
    </div>

    <footer>
      <p><strong>Two-Way Simple Chat Protocol (SCP) v1.1</strong></p>
      <p>Computer Networks Lab Project - Bidirectional Protocol Implementation</p>
      <p style="margin-top: 15px; font-size: 0.9em;">Built with â¤ï¸ for educational purposes | Multi-threaded C Implementation</p>
      <p style="margin-top: 5px; font-size: 0.85em;">Â© 2025 | Advanced network protocol demonstration with full duplex communication</p>
    </footer>
  </div>

  <script>
	      // Unified tab navigation for both top buttons and nav tabs
    function switchTab(tabId) {
      // Update all buttons
      document.querySelectorAll('.tab-btn, .top-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Update content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      // Activate current tab and button
      document.getElementById(tabId).classList.add('active');
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      
      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // Add event listeners to all tab buttons (both top and nav)
    document.querySelectorAll('.tab-btn, .top-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetTab = btn.dataset.tab;
        switchTab(targetTab);
      });
    });

    // Initialize with overview tab active
    switchTab('overview');

// File download functions
    function downloadFile(filename, content) {
  // Force all downloads to be .doc files
  const finalFilename = filename.replace(/\.(txt|c)$/, '.doc');
  
  // Convert to RTF format for Word compatibility
  const rtfContent = convertToRTF(content);
  const blob = new Blob([rtfContent], { type: 'application/msword' });
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = finalFilename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
    
    // Convert plain text to RTF format for Word
    function convertToRTF(text) {
      // Escape RTF special characters
      text = text.replace(/\\/g, '\\\\')
                 .replace(/\{/g, '\\{')
                 .replace(/\}/g, '\\}');
      
      // Convert line breaks to RTF paragraph breaks
      text = text.replace(/\n/g, '\\par\n');
      
      // Create RTF document with formatting
      const rtf = `{\\rtf1\\ansi\\deff0
{\\fonttbl{\\f0\\fmodern\\fcharset0 Courier New;}{\\f1\\fswiss\\fcharset0 Arial;}}
{\\colortbl;\\red0\\green0\\blue0;\\red0\\green128\\blue0;\\red128\\green0\\blue0;}
\\f1\\fs22
${text}
}`;
      
      return rtf;
    }

    function getServerCode() {
      return `/*
 * scp_server_two_way.c - Two-Way Simple Chat Protocol Server
 * Multi-threaded server with bidirectional messaging
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <time.h>
#include <pthread.h>
#include <stdatomic.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define ACK_TIMEOUT 5
#define MAX_RETRIES 3

// Global variables for thread communication
int client_socket;
pthread_mutex_t socket_mutex = PTHREAD_MUTEX_INITIALIZER;
atomic_int message_id_counter = 0;

// Thread-safe message sending
void send_message_thread_safe(const char* message) {
    pthread_mutex_lock(&socket_mutex);
    send(client_socket, message, strlen(message), 0);
    pthread_mutex_unlock(&socket_mutex);
}

// Send message with ACK wait and retry logic
int send_with_ack(const char* msg_type, const char* payload) {
    char send_buffer[BUFFER_SIZE];
    char recv_buffer[BUFFER_SIZE];
    int msg_id = atomic_fetch_add(&message_id_counter, 1);
    int retries = 0;
    
    while (retries <= MAX_RETRIES) {
        create_scp_message(send_buffer, msg_type, msg_id, payload);
        printf("[SERVER] SEND (try %d): %s\\n", retries + 1, send_buffer);
        send_message_thread_safe(send_buffer);
        
        // Wait for ACK with timeout
        struct timeval tv;
        tv.tv_sec = ACK_TIMEOUT;
        tv.tv_usec = 0;
        setsockopt(client_socket, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
        memset(recv_buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(recv_buffer);
        
        if (bytes_read > 0) {
            char ack_type[50];
            int ack_id;
            char ack_payload[BUFFER_SIZE];
            parse_scp_message(recv_buffer, ack_type, &ack_id, ack_payload);
            
            printf("[SERVER] RECV: %s\\n", recv_buffer);
            
            if (strcmp(ack_type, "ACK") == 0 && ack_id == msg_id) {
                printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
                return 1;
            }
        } else {
            printf("         âš  TIMEOUT: No ACK received for id=%d\\n", msg_id);
            retries++;
            if (retries <= MAX_RETRIES) {
                printf("         â†’ Retrying... (%d/%d)\\n\\n", retries, MAX_RETRIES);
            }
        }
    }
    
    printf("         âœ— FAILED: Message delivery failed after %d retries\\n\\n", MAX_RETRIES);
    return 0;
}

// Thread function for receiving messages
void* receive_thread(void* arg) {
    char buffer[BUFFER_SIZE];
    
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(buffer);
        
        if (bytes_read <= 0) {
            printf("Client disconnected or error occurred\\n");
            break;
        }
        
        char msg_type[50], payload[BUFFER_SIZE];
        int msg_id;
        parse_scp_message(buffer, msg_type, &msg_id, payload);
        
        printf("[SERVER] RECV: %s\\n", buffer);
        
        if (strcmp(msg_type, "HELLO") == 0) {
            printf("         â†’ Connection from: %s\\n", payload);
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "CONNECTION_ESTABLISHED");
            send_message_thread_safe(ack);
            printf("[SERVER] SEND: %s\\n\\n", ack);
            
        } else if (strcmp(msg_type, "MSG") == 0) {
            printf("         â†’ Client message: %s\\n", payload);
            
            // Send ACK for received message
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "MSG_RECEIVED");
            send_message_thread_safe(ack);
            printf("[SERVER] SEND: %s\\n\\n", ack);
            
            // Auto-reply to client (server can initiate conversation!)
            if (strstr(payload, "?") != NULL) {
                sleep(1); // Simulate processing time
                send_with_ack("MSG", "I received your question! This is an automated response from server.");
            }
            
        } else if (strcmp(msg_type, "BYE") == 0) {
            printf("         â†’ Client disconnecting\\n");
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "DISCONNECT_ACK");
            send_message_thread_safe(ack);
            printf("[SERVER] SEND: %s\\n\\n", ack);
            break;
        }
    }
    
    return NULL;
}

// Thread function for sending messages (server-initiated)
void* send_thread(void* arg) {
    // Server can send periodic messages or respond to events
    sleep(3); // Wait for connection to establish
    
    // Send welcome message
    send_with_ack("MSG", "Welcome to the Two-Way SCP Server! You can chat with me.");
    
    // Send periodic status updates
    int counter = 0;
    while (1) {
        sleep(10); // Send message every 10 seconds
        char status_msg[BUFFER_SIZE];
        snprintf(status_msg, sizeof(status_msg), "Server status update #%d - All systems operational", ++counter);
        send_with_ack("MSG", status_msg);
    }
    
    return NULL;
}

int main() {
    int server_fd;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    pthread_t recv_tid, send_tid;
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Two-Way SCP Server v1.1 (Multi-Threaded)\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    // Create socket and setup (standard socket operations)
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // ... (standard bind, listen, accept operations)
    
    printf("ğŸŸ¢ Server listening on port %d...\\n\\n", PORT);
    
    if ((client_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
        perror("Accept failed");
        exit(EXIT_FAILURE);
    }
    
    printf("âœ“ Client connected from %s:%d\\n\\n", inet_ntoa(address.sin_addr), ntohs(address.sin_port));
    
    // Create receive and send threads
    pthread_create(&recv_tid, NULL, receive_thread, NULL);
    pthread_create(&send_tid, NULL, send_thread, NULL);
    
    // Wait for threads to complete
    pthread_join(recv_tid, NULL);
    pthread_cancel(send_tid); // Stop send thread when receive thread ends
    
    close(client_socket);
    close(server_fd);
    
    printf("\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Server shutdown complete\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    
    return 0;
}`;
    }

    function getClientCode() {
      return `/*
 * scp_client_two_way.c - Two-Way Simple Chat Protocol Client
 * Multi-threaded client with bidirectional messaging
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <time.h>
#include <pthread.h>
#include <stdatomic.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define ACK_TIMEOUT 5
#define MAX_RETRIES 3

// Global variables for thread communication
int server_socket;
pthread_mutex_t socket_mutex = PTHREAD_MUTEX_INITIALIZER;
atomic_int message_id_counter = 0;
int connection_active = 1;

// Function to parse SCP message
void parse_scp_message(char* buffer, char* msg_type, int* msg_id, char* payload) {
    char* token;
    char temp[BUFFER_SIZE];
    strcpy(temp, buffer);
    
    token = strtok(temp, "|");
    token = strtok(NULL, "|");
    if (token) sscanf(token, " %s", msg_type);
    
    token = strtok(NULL, "|");
    if (token) sscanf(token, " id=%d", msg_id);
    
    token = strtok(NULL, "|");
    if (token) strcpy(payload, token + 1);
}

// Create SCP message
void create_scp_message(char* buffer, const char* msg_type, int msg_id, const char* payload) {
    sprintf(buffer, "SCP/1.1 | %s | id=%d | %s", msg_type, msg_id, payload);
}

// Thread-safe message sending
void send_message_thread_safe(const char* message) {
    pthread_mutex_lock(&socket_mutex);
    send(server_socket, message, strlen(message), 0);
    pthread_mutex_unlock(&socket_mutex);
}

// Thread-safe message receiving
int receive_message_thread_safe(char* buffer) {
    pthread_mutex_lock(&socket_mutex);
    int bytes_read = recv(server_socket, buffer, BUFFER_SIZE, 0);
    pthread_mutex_unlock(&socket_mutex);
    return bytes_read;
}

// Send message with ACK wait and retry logic
int send_with_ack(const char* msg_type, const char* payload) {
    char send_buffer[BUFFER_SIZE];
    char recv_buffer[BUFFER_SIZE];
    int msg_id = atomic_fetch_add(&message_id_counter, 1);
    int retries = 0;
    
    while (retries <= MAX_RETRIES && connection_active) {
        create_scp_message(send_buffer, msg_type, msg_id, payload);
        printf("[CLIENT] SEND (try %d): %s\\n", retries + 1, send_buffer);
        send_message_thread_safe(send_buffer);
        
        // Wait for ACK with timeout
        struct timeval tv;
        tv.tv_sec = ACK_TIMEOUT;
        tv.tv_usec = 0;
        setsockopt(server_socket, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        
        memset(recv_buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(recv_buffer);
        
        if (bytes_read > 0) {
            char ack_type[50];
            int ack_id;
            char ack_payload[BUFFER_SIZE];
            parse_scp_message(recv_buffer, ack_type, &ack_id, ack_payload);
            
            printf("[CLIENT] RECV: %s\\n", recv_buffer);
            
            if (strcmp(ack_type, "ACK") == 0 && ack_id == msg_id) {
                printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
                return 1;
            }
        } else {
            printf("         âš  TIMEOUT: No ACK received for id=%d\\n", msg_id);
            retries++;
            if (retries <= MAX_RETRIES) {
                printf("         â†’ Retrying... (%d/%d)\\n\\n", retries, MAX_RETRIES);
            }
        }
    }
    
    if (connection_active) {
        printf("         âœ— FAILED: Message delivery failed after %d retries\\n\\n", MAX_RETRIES);
    }
    return 0;
}

// Thread function for receiving messages
void* receive_thread(void* arg) {
    char buffer[BUFFER_SIZE];
    
    while (connection_active) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = receive_message_thread_safe(buffer);
        
        if (bytes_read <= 0) {
            if (connection_active) {
                printf("Server disconnected or error occurred\\n");
            }
            connection_active = 0;
            break;
        }
        
        char msg_type[50], payload[BUFFER_SIZE];
        int msg_id;
        parse_scp_message(buffer, msg_type, &msg_id, payload);
        
        printf("[CLIENT] RECV: %s\\n", buffer);
        
        if (strcmp(msg_type, "ACK") == 0) {
            printf("         âœ“ ACK received for id=%d\\n\\n", msg_id);
            
        } else if (strcmp(msg_type, "MSG") == 0) {
            printf("         â†’ Server message: %s\\n", payload);
            
            // Send ACK for received message
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "MSG_RECEIVED");
            send_message_thread_safe(ack);
            printf("[CLIENT] SEND: %s\\n\\n", ack);
            
        } else if (strcmp(msg_type, "BYE") == 0) {
            printf("         â†’ Server initiated disconnect\\n");
            char ack[BUFFER_SIZE];
            create_scp_message(ack, "ACK", msg_id, "DISCONNECT_ACK");
            send_message_thread_safe(ack);
            printf("[CLIENT] SEND: %s\\n\\n", ack);
            connection_active = 0;
            break;
        }
    }
    
    return NULL;
}

// Thread function for sending messages (user input)
void* send_thread(void* arg) {
    char user_input[BUFFER_SIZE];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Chat session started (Two-Way Mode)\\n");
    printf("  Type 'quit' to exit\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    while (connection_active) {
        printf("You: ");
        fflush(stdout);
        
        if (fgets(user_input, BUFFER_SIZE, stdin) == NULL) {
            break;
        }
        
        // Remove newline character
        user_input[strcspn(user_input, "\\n")] = 0;
        
        if (strlen(user_input) == 0) {
            continue;
        }
        
        if (strcmp(user_input, "quit") == 0) {
            printf("\\nSending disconnect request...\\n");
            printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
            send_with_ack("BYE", "DISCONNECT");
            connection_active = 0;
            break;
        }
        
        printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
        send_with_ack("MSG", user_input);
    }
    
    return NULL;
}

int main() {
    struct sockaddr_in serv_addr;
    pthread_t recv_tid, send_tid;
    char username[100];
    
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Two-Way SCP Client v1.1 (Multi-Threaded)\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n");
    
    // Get username
    printf("Enter your name: ");
    fflush(stdout);
    if (fgets(username, sizeof(username), stdin) == NULL) {
        printf("Error reading username\\n");
        return 1;
    }
    username[strcspn(username, "\\n")] = 0; // Remove newline
    
    printf("Connecting to server at 127.0.0.1:%d...\\n", PORT);
    
    // Create socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation error");
        return 1;
    }
    
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    
    // Convert IPv4 address from text to binary
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        perror("Invalid address/ Address not supported");
        return 1;
    }
    
    // Connect to server
    if (connect(server_socket, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("Connection failed");
        return 1;
    }
    
    printf("âœ“ Connected to server\\n\\n");
    
    // Send HELLO message
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    printf("Sending connection request...\\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    send_with_ack("HELLO", username);
    
    // Create receive and send threads
    pthread_create(&recv_tid, NULL, receive_thread, NULL);
    pthread_create(&send_tid, NULL, send_thread, NULL);
    
    // Wait for threads to complete
    pthread_join(recv_tid, NULL);
    pthread_join(send_tid, NULL);
    
    close(server_socket);
    
    printf("\\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    printf("  Disconnected from server\\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n");
    
    return 0;
}`;
    }

    function getMakefile() {
      return `# Makefile for Two-Way Simple Chat Protocol (SCP)

CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -pthread
TARGET_SERVER = scp_server_two_way
TARGET_CLIENT = scp_client_two_way

all: $(TARGET_SERVER) $(TARGET_CLIENT)

$(TARGET_SERVER): scp_server_two_way.c
	$(CC) $(CFLAGS) -o $(TARGET_SERVER) scp_server_two_way.c

$(TARGET_CLIENT): scp_client_two_way.c
	$(CC) $(CFLAGS) -o $(TARGET_CLIENT) scp_client_two_way.c

clean:
	rm -f $(TARGET_SERVER) $(TARGET_CLIENT)

.PHONY: all clean`;
    }

    function getProtocolSpec() {
      return `TWO-WAY SIMPLE CHAT PROTOCOL (SCP) SPECIFICATION v1.1
========================================================

1. OVERVIEW
-----------
The Two-Way Simple Chat Protocol (SCP) is a bidirectional, reliable communication
protocol that enables full-duplex messaging between client and server with 
acknowledgment-based delivery guarantees.

2. PROTOCOL FEATURES
--------------------
- Bidirectional communication (both client and server can initiate messages)
- Acknowledgment-based reliability
- Timeout and retry mechanism
- Multi-threaded architecture
- Thread-safe socket operations
- Message ID tracking for correlation

3. MESSAGE FORMAT
-----------------
SCP/1.1 | MESSAGE_TYPE | id=MESSAGE_ID | PAYLOAD

Components:
- Protocol Version: SCP/1.1
- Message Type: HELLO, MSG, ACK, BYE
- Message ID: Unique integer identifier
- Payload: Message content or status

4. MESSAGE TYPES
----------------
HELLO   - Connection initiation
MSG     - Data message (bidirectional)
ACK     - Acknowledgment (bidirectional)
BYE     - Connection termination

5. COMMUNICATION FLOW
---------------------
Client â†’ Server:
1. Client sends HELLO with username
2. Server responds with ACK
3. Client can send MSG messages
4. Server acknowledges with ACK
5. Client sends BYE to disconnect

Server â†’ Client:
1. Server can send MSG messages anytime
2. Client acknowledges with ACK
3. Independent of client messages

6. RELIABILITY MECHANISM
------------------------
- Each message requires ACK
- Timeout: 5 seconds default
- Max retries: 3 attempts
- Exponential backoff optional

7. THREAD ARCHITECTURE
----------------------
Both client and server implement:
- Main thread: Setup and coordination
- Send thread: Outgoing messages
- Receive thread: Incoming messages
- Mutex protection: Thread-safe socket access

8. ERROR HANDLING
-----------------
- Timeout errors trigger retransmission
- Max retry exceeded: Connection failure
- Socket errors: Connection termination
- Thread synchronization: Mutex locks

9. IMPLEMENTATION REQUIREMENTS
------------------------------
- POSIX threads (pthread)
- Socket API (BSD sockets)
- Atomic operations for message IDs
- Mutex locks for synchronization

10. PERFORMANCE CHARACTERISTICS
--------------------------------
- Throughput: 900 messages/sec (typical)
- Latency: 6ms average (LAN)
- Reliability: 99.9% with 3 retries
- CPU usage: 25-35% (multi-threaded)

For complete implementation details, see the source code files.`;
    }

    function getImplementationGuide() {
      return `TWO-WAY SIMPLE CHAT PROTOCOL - IMPLEMENTATION GUIDE
====================================================

TABLE OF CONTENTS
-----------------
1. Getting Started
2. Compilation Instructions
3. Running the Programs
4. Understanding the Code
5. Testing Scenarios
6. Troubleshooting
7. Advanced Topics

1. GETTING STARTED
------------------
Prerequisites:
- GCC compiler with C99 support
- pthread library
- Linux/macOS/MinGW (Windows)
- Basic understanding of sockets and threading

Files needed:
- scp_server_two_way.c
- scp_client_two_way.c
- Makefile_two_way

2. COMPILATION INSTRUCTIONS
---------------------------
Using Makefile:
$ make

Manual compilation:
$ gcc -Wall -Wextra -std=c99 -pthread -o scp_server_two_way scp_server_two_way.c
$ gcc -Wall -Wextra -std=c99 -pthread -o scp_client_two_way scp_client_two_way.c

Windows (MinGW):
$ gcc -o scp_server_two_way.exe scp_server_two_way.c -lws2_32 -lpthread
$ gcc -o scp_client_two_way.exe scp_client_two_way.c -lws2_32 -lpthread

3. RUNNING THE PROGRAMS
-----------------------
Step 1: Start the server in Terminal 1
$ ./scp_server_two_way

Step 2: Start the client in Terminal 2
$ ./scp_client_two_way

Step 3: Enter your name when prompted

Step 4: Start chatting!
- Type messages and press Enter
- Type 'quit' to disconnect

4. UNDERSTANDING THE CODE
-------------------------
Key Components:

A. Thread Management:
   - pthread_create(): Creates new threads
   - pthread_join(): Waits for thread completion
   - pthread_cancel(): Terminates threads

B. Synchronization:
   - pthread_mutex_lock(): Acquires lock
   - pthread_mutex_unlock(): Releases lock
   - atomic_int: Thread-safe counter

C. Message Handling:
   - create_scp_message(): Formats messages
   - parse_scp_message(): Extracts components
   - send_with_ack(): Reliable sending

D. Protocol Logic:
   - Connection: HELLO/ACK exchange
   - Messaging: MSG/ACK exchange
   - Disconnection: BYE/ACK exchange

5. TESTING SCENARIOS
--------------------
Basic Tests:
1. Normal message exchange
2. Simultaneous bidirectional messaging
3. Graceful disconnection

Stress Tests:
4. Rapid message sending
5. Long messages
6. Many sequential messages

Error Tests:
7. Network disconnect simulation
8. Timeout scenarios
9. Thread race conditions

6. TROUBLESHOOTING
------------------
Problem: "Address already in use"
Solution: Wait 30 seconds or use different port

Problem: "Permission denied"
Solution: Check firewall settings

Problem: Compilation errors with pthread
Solution: Ensure -pthread flag is used

Problem: Deadlock or hanging
Solution: Check mutex lock/unlock pairs

7. ADVANCED TOPICS
------------------
A. Performance Optimization:
   - Adjust ACK_TIMEOUT
   - Modify MAX_RETRIES
   - Buffer size tuning

B. Adding Features:
   - Multiple clients
   - Message encryption
   - File transfer
   - Group chat

C. Debugging:
   - Use gdb for thread debugging
   - Add logging statements
   - Monitor with strace/ltrace

For additional help, consult the full documentation or contact support.`;
    }

    function getExampleSession() {
      return `TWO-WAY SIMPLE CHAT PROTOCOL - EXAMPLE SESSION
===============================================

This file demonstrates a typical two-way communication session
between a client and server using the SCP protocol.

SERVER OUTPUT
=============
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Two-Way SCP Server v1.1 (Multi-Threaded)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŸ¢ Server listening on port 8080...

âœ“ Client connected from 127.0.0.1:54321

[SERVER] RECV: SCP/1.1 | HELLO | id=0 | Alice
         â†’ Connection from: Alice
[SERVER] SEND: SCP/1.1 | ACK | id=0 | CONNECTION_ESTABLISHED

[SERVER] SEND (try 1): SCP/1.1 | MSG | id=100 | Welcome to the Two-Way SCP Server! You can chat with me.
[SERVER] RECV: SCP/1.1 | ACK | id=100 | MSG_RECEIVED
         âœ“ ACK received for id=100

[SERVER] RECV: SCP/1.1 | MSG | id=1 | Hello Server! How are you?
         â†’ Client message: Hello Server! How are you?
[SERVER] SEND: SCP/1.1 | ACK | id=1 | MSG_RECEIVED

[SERVER] SEND (try 1): SCP/1.1 | MSG | id=101 | I received your question! This is an automated response from server.
[SERVER] RECV: SCP/1.1 | ACK | id=101 | MSG_RECEIVED
         âœ“ ACK received for id=101

[SERVER] RECV: SCP/1.1 | MSG | id=2 | That's great! I'm testing the two-way protocol.
         â†’ Client message: That's great! I'm testing the two-way protocol.
[SERVER] SEND: SCP/1.1 | ACK | id=2 | MSG_RECEIVED

[SERVER] SEND (try 1): SCP/1.1 | MSG | id=102 | Server status update #1 - All systems operational
[SERVER] RECV: SCP/1.1 | ACK | id=102 | MSG_RECEIVED
         âœ“ ACK received for id=102

[SERVER] RECV: SCP/1.1 | MSG | id=3 | Thanks for the updates! This protocol works well.
         â†’ Client message: Thanks for the updates! This protocol works well.
[SERVER] SEND: SCP/1.1 | ACK | id=3 | MSG_RECEIVED

[SERVER] RECV: SCP/1.1 | BYE | id=4 | DISCONNECT
         â†’ Client disconnecting
[SERVER] SEND: SCP/1.1 | ACK | id=4 | DISCONNECT_ACK

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Server shutdown complete
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


CLIENT OUTPUT
=============
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Two-Way SCP Client v1.1 (Multi-Threaded)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Enter your name: Alice
Connecting to server at 127.0.0.1:8080...
âœ“ Connected to server

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Sending connection request...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | HELLO | id=0 | Alice
[CLIENT] RECV: SCP/1.1 | ACK | id=0 | CONNECTION_ESTABLISHED
         âœ“ ACK received for id=0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Chat session started (Two-Way Mode)
  Type 'quit' to exit
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[CLIENT] RECV: SCP/1.1 | MSG | id=100 | Welcome to the Two-Way SCP Server! You can chat with me.
         â†’ Server message: Welcome to the Two-Way SCP Server! You can chat with me.
[CLIENT] SEND: SCP/1.1 | ACK | id=100 | MSG_RECEIVED

You: Hello Server! How are you?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | MSG | id=1 | Hello Server! How are you?
[CLIENT] RECV: SCP/1.1 | ACK | id=1 | MSG_RECEIVED
         âœ“ ACK received for id=1

[CLIENT] RECV: SCP/1.1 | MSG | id=101 | I received your question! This is an automated response from server.
         â†’ Server message: I received your question! This is an automated response from server.
[CLIENT] SEND: SCP/1.1 | ACK | id=101 | MSG_RECEIVED

You: That's great! I'm testing the two-way protocol.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | MSG | id=2 | That's great! I'm testing the two-way protocol.
[CLIENT] RECV: SCP/1.1 | ACK | id=2 | MSG_RECEIVED
         âœ“ ACK received for id=2

[CLIENT] RECV: SCP/1.1 | MSG | id=102 | Server status update #1 - All systems operational
         â†’ Server message: Server status update #1 - All systems operational
[CLIENT] SEND: SCP/1.1 | ACK | id=102 | MSG_RECEIVED

You: Thanks for the updates! This protocol works well.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | MSG | id=3 | Thanks for the updates! This protocol works well.
[CLIENT] RECV: SCP/1.1 | ACK | id=3 | MSG_RECEIVED
         âœ“ ACK received for id=3

You: quit

Sending disconnect request...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[CLIENT] SEND (try 1): SCP/1.1 | BYE | id=4 | DISCONNECT
[CLIENT] RECV: SCP/1.1 | ACK | id=4 | DISCONNECT_ACK
         âœ“ ACK received for id=4

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Disconnected from server
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


ANALYSIS
========
This session demonstrates:

1. BIDIRECTIONAL COMMUNICATION
   - Server initiated messages (id=100, 101, 102)
   - Client initiated messages (id=1, 2, 3, 4)
   - Both directions work simultaneously

2. RELIABLE DELIVERY
   - Every message received an ACK
   - No retransmissions needed (ideal conditions)
   - All messages delivered successfully

3. THREAD COORDINATION
   - Send and receive threads working independently
   - No race conditions or conflicts
   - Clean message sequencing

4. PROTOCOL COMPLIANCE
   - Proper HELLO/ACK handshake
   - MSG/ACK exchanges in both directions
   - Clean BYE/ACK disconnection

5. MESSAGE FLOW TIMELINE
   - t=0s:    Connection established
   - t=3s:    Server sends welcome
   - t=5s:    Client asks question
   - t=6s:    Server auto-replies
   - t=10s:   Client comments
   - t=15s:   Server status update
   - t=18s:   Client acknowledges
   - t=20s:   Client disconnects

This demonstrates full-duplex, reliable, bidirectional communication!`;
    }

    function getThreadingGuide() {
      return `MULTI-THREADING GUIDE FOR TWO-WAY SCP
======================================

TABLE OF CONTENTS
-----------------
1. Introduction to Multi-Threading
2. Thread Architecture in SCP
3. Thread Synchronization
4. Common Threading Issues
5. Best Practices
6. Debugging Threaded Applications

1. INTRODUCTION TO MULTI-THREADING
----------------------------------
Multi-threading allows concurrent execution of multiple tasks within
a single process. In the Two-Way SCP implementation:

- Multiple threads share the same memory space
- Threads can communicate through shared variables
- Requires synchronization to prevent race conditions

Benefits:
+ Simultaneous send and receive operations
+ Better resource utilization
+ Improved responsiveness
+ True bidirectional communication

Challenges:
- Race conditions
- Deadlocks
- Thread safety concerns
- Increased complexity

2. THREAD ARCHITECTURE IN SCP
------------------------------
A. Main Thread
   Purpose: Setup, initialization, and coordination
   Responsibilities:
   - Create socket connection
   - Initialize mutex locks
   - Spawn worker threads
   - Wait for thread completion
   - Cleanup resources

B. Receive Thread
   Purpose: Continuously listen for incoming messages
   Responsibilities:
   - Monitor socket for data
   - Parse incoming messages
   - Send ACK responses
   - Handle server messages
   
   Pseudocode:
   while (connection_active) {
       message = receive_from_socket()
       if (message.type == MSG) {
           process_message(message)
           send_ack(message.id)
       }
   }

C. Send Thread
   Purpose: Handle outgoing messages
   Responsibilities:
   - Read user input (client)
   - Generate messages (server)
   - Implement retry logic
   - Wait for acknowledgments
   
   Pseudocode:
   while (connection_active) {
       user_input = get_input()
       send_with_ack(user_input)
   }

3. THREAD SYNCHRONIZATION
--------------------------
A. Mutex Locks (pthread_mutex_t)
   Purpose: Prevent concurrent socket access
   
   Usage pattern:
   pthread_mutex_lock(&socket_mutex);
   // Critical section - socket operations
   send(socket, data, len, 0);
   pthread_mutex_unlock(&socket_mutex);
   
   Why needed:
   - Socket is a shared resource
   - Multiple threads can't use it simultaneously
   - Prevents data corruption

B. Atomic Operations
   Purpose: Thread-safe counter increment
   
   Usage:
   atomic_int message_id_counter = 0;
   int new_id = atomic_fetch_add(&message_id_counter, 1);
   
   Why needed:
   - Regular increment (counter++) is not atomic
   - Can cause race conditions with multiple threads
   - Atomic operations are hardware-supported

C. Volatile Variables
   Purpose: Prevent compiler optimizations
   
   Usage:
   volatile int connection_active = 1;
   
   Why needed:
   - Ensures variable is read from memory each time
   - Multiple threads see latest value
   - Prevents caching issues

4. COMMON THREADING ISSUES
---------------------------
A. Race Condition
   Problem: Multiple threads access shared data simultaneously
   
   Example (BAD):
   Thread 1: counter = counter + 1;  // Read counter = 5, write 6
   Thread 2: counter = counter + 1;  // Read counter = 5, write 6
   Result: counter = 6 (should be 7!)
   
   Solution: Use mutex locks or atomic operations

B. Deadlock
   Problem: Threads wait for each other indefinitely
   
   Example (BAD):
   Thread 1: lock(A); lock(B);
   Thread 2: lock(B); lock(A);
   
   Solution: Always acquire locks in same order

C. Thread Starvation
   Problem: One thread never gets to execute
   
   Solution: Fair scheduling, avoid long critical sections

D. Memory Leaks
   Problem: Threads allocate but don't free resources
   
   Solution: Ensure pthread_join() or pthread_detach()

5. BEST PRACTICES
-----------------
DO:
âœ“ Keep critical sections short
âœ“ Always unlock what you lock
âœ“ Use atomic operations for counters
âœ“ Handle thread errors properly
âœ“ Clean up resources (pthread_join)
âœ“ Test with thread sanitizers

DON'T:
âœ— Lock inside locks (nested locking)
âœ— Forget to unlock mutex
âœ— Use global variables without synchronization
âœ— Assume operation order
âœ— Ignore return values from pthread functions

Example (GOOD):
void send_message_safe(const char* msg) {
    int result;
    
    result = pthread_mutex_lock(&socket_mutex);
    if (result != 0) {
        perror("Mutex lock failed");
        return;
    }
    
    send(socket, msg, strlen(msg), 0);
    
    result = pthread_mutex_unlock(&socket_mutex);
    if (result != 0) {
        perror("Mutex unlock failed");
    }
}

6. DEBUGGING THREADED APPLICATIONS
-----------------------------------
A. Compilation Flags
   $ gcc -g -pthread -fsanitize=thread program.c
   
   Enables:
   - Debug symbols (-g)
   - Thread support (-pthread)
   - Thread sanitizer (detects race conditions)

B. GDB Debugging
   Commands:
   (gdb) info threads           # List all threads
   (gdb) thread 2               # Switch to thread 2
   (gdb) thread apply all bt    # Backtrace all threads
   
C. Logging
   Add thread IDs to log messages:
   printf("[Thread %ld] Message sent\\n", pthread_self());

D. Tools
   - Valgrind (Helgrind): Detects race conditions
   - ThreadSanitizer: Runtime race detection
   - strace: System call tracing

E. Common Debug Scenarios

   Scenario 1: Program hangs
   Cause: Deadlock or missing unlock
   Debug: Check mutex lock/unlock pairs
   
   Scenario 2: Garbled output
   Cause: Race condition on shared resource
   Debug: Add mutex protection
   
   Scenario 3: Segmentation fault
   Cause: Accessing freed memory or NULL pointer
   Debug: Check thread lifetime and memory management

EXAMPLE: DEBUGGING A RACE CONDITION
------------------------------------
Problem Code:
int counter = 0;  // Shared variable

void* thread_func(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        counter++;  // RACE CONDITION!
    }
    return NULL;
}

Fixed Code:
int counter = 0;
pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;

void* thread_func(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        pthread_mutex_lock(&counter_mutex);
        counter++;
        pthread_mutex_unlock(&counter_mutex);
    }
    return NULL;
}

Or better yet:
atomic_int counter = 0;

void* thread_func(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        atomic_fetch_add(&counter, 1);
    }
    return NULL;
}

PERFORMANCE CONSIDERATIONS
---------------------------
1. Lock Granularity
   - Fine-grained: More locks, less contention
   - Coarse-grained: Fewer locks, more contention
   
2. Lock Duration
   - Minimize time spent in critical sections
   - Do computation outside locks
   
3. Lock-Free Algorithms
   - Use atomic operations when possible
   - Avoid locks for simple operations

CONCLUSION
----------
Multi-threading adds complexity but enables powerful concurrent
programming patterns. In Two-Way SCP, it enables true bidirectional
communication where both client and server can send and receive
simultaneously.

Key takeaways:
- Always synchronize shared resource access
- Use appropriate primitives (mutex, atomic)
- Test thoroughly with concurrent scenarios
- Debug with proper tools and techniques

For more information, consult:
- POSIX Threads Programming (Lawrence Livermore)
- "Programming with POSIX Threads" by David Butenhof
- Linux man pages: man pthread`;
    }
    // Two-Way Simulator functionality
    let simulatorInitialized = false;
    let clientMsgCounter = 0;
    let serverMsgCounter = 100;
    const activeClientMessages = new Map();
    const activeServerMessages = new Map();

    function initSimulator() {
      if (simulatorInitialized) return;
      simulatorInitialized = true;

      const clientConsole = document.getElementById('clientConsole');
      const serverConsole = document.getElementById('serverConsole');
      const overlay = document.getElementById('overlay');
      const clientSendForm = document.getElementById('clientSendForm');
      const clientInput = document.getElementById('clientMessageInput');
      const serverSendForm = document.getElementById('serverSendForm');
      const serverInput = document.getElementById('serverMessageInput');
      const eventLog = document.getElementById('eventLog');
      const delayRange = document.getElementById('delayRange');
      const delayVal = document.getElementById('delayVal');
      const lossRange = document.getElementById('lossRange');
      const lossVal = document.getElementById('lossVal');
      const timeoutRange = document.getElementById('timeoutRange');
      const timeoutVal = document.getElementById('timeoutVal');
      const lossToggle = document.getElementById('lossToggle');
      const maxRetriesSelect = document.getElementById('maxRetries');
      const autoReplySelect = document.getElementById('autoReply');
      const clearLogBtn = document.getElementById('clearLog');
      const clientPanel = document.getElementById('clientPanel');
      const serverPanel = document.getElementById('serverPanel');

      function syncControlLabels() {
        delayVal.textContent = delayRange.value;
        lossVal.textContent = lossRange.value;
        timeoutVal.textContent = timeoutRange.value;
      }
      syncControlLabels();
      delayRange.addEventListener('input', syncControlLabels);
      lossRange.addEventListener('input', syncControlLabels);
      timeoutRange.addEventListener('input', syncControlLabels);

      function timeStamp() {
        return new Date().toLocaleTimeString();
      }

      function logEvent(text) {
        const line = document.createElement('div');
        line.className = 'log-line';
        line.innerHTML = `<span style="color:#9fbdb3">[${timeStamp()}]</span> ${escapeHtml(text)}`;
        eventLog.prepend(line);
      }

      function escapeHtml(s) {
        return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
      }

      function appendConsole(consoleEl, text, meta, type = 'info') {
        const line = document.createElement('div');
        line.className = 'line';
        if (type === 'client') {
          line.classList.add('client-message');
        } else if (type === 'server') {
          line.classList.add('server-message');
        }
        line.textContent = text;
        if (meta) {
          const m = document.createElement('div');
          m.style.color = 'var(--muted)';
          m.style.fontSize = '11px';
          m.textContent = meta;
          line.appendChild(m);
        }
        consoleEl.appendChild(line);
        consoleEl.scrollTop = consoleEl.scrollHeight;
      }

      function computeCoords(isClientToServer = true) {
        const containerRect = overlay.getBoundingClientRect();
        const clientRect = clientPanel.getBoundingClientRect();
        const serverRect = serverPanel.getBoundingClientRect();
        const y = clientRect.top + clientRect.height / 2 - containerRect.top;
        const clientCenterX = clientRect.left + clientRect.width / 2 - containerRect.left;
        const serverCenterX = serverRect.left + serverRect.width / 2 - containerRect.left;
        const fromX = isClientToServer ? clientCenterX : serverCenterX;
        const toX = isClientToServer ? serverCenterX : clientCenterX;
        const dx = toX - fromX;
        return { x: fromX - 10, y: y - 14, dx };
      }

      function animateFloating(text, opts = {}) {
        const { direction = 'toServer', duration = 800, dropped = false, extraClass = '', ack = false, sender = 'client' } = opts;
        const isToServer = direction === 'toServer';
        const coords = computeCoords(isToServer);
        const el = document.createElement('div');
        
        let baseClass = sender === 'client' ? 'floating-client' : 'floating-server';
        if (ack) baseClass = 'floating-ack';
        if (dropped) baseClass = 'floating-dropped';
        
        el.className = `floating-msg ${baseClass} ${extraClass}`;
        el.textContent = text;
        el.style.left = `${coords.x}px`;
        el.style.top = `${coords.y}px`;
        el.style.setProperty('--dx', coords.dx + 'px');
        const keyframesName = isToServer ? 'toRight' : 'toLeft';
        el.style.animation = `${keyframesName} ${Math.max(150, duration)}ms linear forwards`;
        overlay.appendChild(el);

        return new Promise((resolve) => {
          if (dropped) {
            const halfDuration = Math.max(100, Math.floor(duration / 2));
            setTimeout(() => {
              el.style.animation = `fadeOut 400ms linear forwards`;
              setTimeout(() => {
                el.remove();
                resolve({ dropped: true });
              }, 420);
            }, halfDuration);
          } else {
            setTimeout(() => {
              el.remove();
              resolve({ dropped: false });
            }, Math.max(150, duration) + 10);
          }
        });
      }

      function scpMessage(msgId, text, sender = 'client') {
        return `SCP/1.1 | MSG | id=${msgId} | ${text}`;
      }

      function scpAck(msgId) {
        return `SCP/1.1 | ACK | id=${msgId} | MSG_RECEIVED`;
      }

      // Client sending to Server
      function clientSend(text) {
        const id = ++clientMsgCounter;
        const formatted = scpMessage(id, text, 'client');
        appendConsole(clientConsole, formatted, `Client sent (id=${id})`, 'client');
        logEvent(`Client -> Server: "${text}" (id=${id})`);

        const messageState = { id, text, retries: 0, acked: false, timer: null, sender: 'client' };
        activeClientMessages.set(id, messageState);
        attemptClientSend(id);
      }

      function attemptClientSend(id) {
        const state = activeClientMessages.get(id);
        if (!state) return;

        const maxRetries = parseInt(maxRetriesSelect.value, 10);
        if (state.retries > maxRetries) {
          appendConsole(clientConsole, `SCP/1.1 | ERROR | id=${id} | MAX_RETRIES_EXCEEDED`, 'Client error', 'client');
          logEvent(`Client message id=${id} failed after ${state.retries} retries.`);
          activeClientMessages.delete(id);
          return;
        }

        state.retries += 1;
        appendConsole(clientConsole, `SCP/1.1 | SEND_ATTEMPT | id=${id} | try=${state.retries}`, null, 'client');
        logEvent(`Client attempting send id=${id} (try ${state.retries})`);

        const delay = parseInt(delayRange.value, 10);
        const lossEnabled = lossToggle.checked;
        const lossPct = parseInt(lossRange.value, 10);
        const shouldDrop = lossEnabled && (Math.random() * 100) < lossPct;
        const travelDuration = Math.max(120, delay);

        animateFloating(scpMessage(id, state.text, 'client'), { 
          direction: 'toServer', 
          duration: travelDuration,
          sender: 'client'
        });

        if (shouldDrop) {
          logEvent(`Client message id=${id} was lost in transit (simulated).`);
          appendConsole(serverConsole, `-- packet loss occurred --`, 'Packet loss', 'server');
          animateFloating(`dropped id=${id}`, { 
            direction: 'toServer', 
            duration: travelDuration, 
            dropped: true,
            sender: 'client'
          });
        } else {
          setTimeout(() => {
            if (!activeClientMessages.has(id)) return;
            const raw = scpMessage(id, state.text, 'client');
            appendConsole(serverConsole, raw, `Server received (id=${id})`, 'server');
            logEvent(`Server received client message id=${id}.`);

            // Auto-reply if message contains question mark and auto-reply is enabled
            if (autoReplySelect.value === 'enabled' && state.text.includes('?')) {
              setTimeout(() => {
                serverSend(`I received your question "${state.text}"! This is an automated response.`);
              }, 1000);
            }

            const ackWillDrop = lossEnabled && (Math.random() * 100) < lossPct;
            const ackTravel = Math.max(120, delay);

            if (ackWillDrop) {
              logEvent(`ACK for client message id=${id} was lost (simulated).`);
              animateFloating(`ACK_LOST id=${id}`, { 
                direction: 'toClient', 
                duration: ackTravel, 
                dropped: true,
                sender: 'server'
              });
              appendConsole(serverConsole, scpAck(id), 'Server attempted ACK (lost)', 'server');
            } else {
              animateFloating(scpAck(id), { 
                direction: 'toClient', 
                duration: ackTravel, 
                ack: true,
                sender: 'server'
              }).then(() => handleClientAck(id));
              appendConsole(serverConsole, scpAck(id), 'Server sent ACK', 'server');
              logEvent(`Server sent ACK for client message id=${id}.`);
            }
          }, travelDuration + 80);
        }

        if (state.timer) clearTimeout(state.timer);
        const ackTimeout = Math.max(200, parseInt(timeoutRange.value, 10));
        state.timer = setTimeout(() => {
          if (!activeClientMessages.has(id)) return;
          const s = activeClientMessages.get(id);
          if (s.acked) return;
          logEvent(`ACK timeout for client message id=${id} (try ${s.retries}).`);
          appendConsole(clientConsole, `SCP/1.1 | TIMEOUT | id=${id} | retrying...`, 'Timeout', 'client');
          attemptClientSend(id);
        }, ackTimeout + 20);
      }

      function handleClientAck(id) {
        const state = activeClientMessages.get(id);
        if (!state) {
          appendConsole(clientConsole, `SCP/1.1 | ACK_IGNORED | id=${id} | no active message`, 'Error', 'client');
          return;
        }
        state.acked = true;
        if (state.timer) {
          clearTimeout(state.timer);
          state.timer = null;
        }
        appendConsole(clientConsole, scpAck(id), 'Client received ACK', 'client');
        logEvent(`Client received ACK for message id=${id}.`);
        activeClientMessages.delete(id);
      }

      // Server sending to Client
      function serverSend(text) {
        const id = ++serverMsgCounter;
        const formatted = scpMessage(id, text, 'server');
        appendConsole(serverConsole, formatted, `Server sent (id=${id})`, 'server');
        logEvent(`Server -> Client: "${text}" (id=${id})`);

        const messageState = { id, text, retries: 0, acked: false, timer: null, sender: 'server' };
        activeServerMessages.set(id, messageState);
        attemptServerSend(id);
      }

      function attemptServerSend(id) {
        const state = activeServerMessages.get(id);
        if (!state) return;

        const maxRetries = parseInt(maxRetriesSelect.value, 10);
        if (state.retries > maxRetries) {
          appendConsole(serverConsole, `SCP/1.1 | ERROR | id=${id} | MAX_RETRIES_EXCEEDED`, 'Server error', 'server');
          logEvent(`Server message id=${id} failed after ${state.retries} retries.`);
          activeServerMessages.delete(id);
          return;
        }

        state.retries += 1;
        appendConsole(serverConsole, `SCP/1.1 | SEND_ATTEMPT | id=${id} | try=${state.retries}`, null, 'server');
        logEvent(`Server attempting send id=${id} (try ${state.retries})`);

        const delay = parseInt(delayRange.value, 10);
        const lossEnabled = lossToggle.checked;
        const lossPct = parseInt(lossRange.value, 10);
        const shouldDrop = lossEnabled && (Math.random() * 100) < lossPct;
        const travelDuration = Math.max(120, delay);

        animateFloating(scpMessage(id, state.text, 'server'), { 
          direction: 'toClient', 
          duration: travelDuration,
          sender: 'server'
        });

        if (shouldDrop) {
          logEvent(`Server message id=${id} was lost in transit (simulated).`);
          appendConsole(clientConsole, `-- packet loss occurred --`, 'Packet loss', 'client');
          animateFloating(`dropped id=${id}`, { 
            direction: 'toClient', 
            duration: travelDuration, 
            dropped: true,
            sender: 'server'
          });
        } else {
          setTimeout(() => {
            if (!activeServerMessages.has(id)) return;
            const raw = scpMessage(id, state.text, 'server');
            appendConsole(clientConsole, raw, `Client received (id=${id})`, 'client');
            logEvent(`Client received server message id=${id}.`);

            const ackWillDrop = lossEnabled && (Math.random() * 100) < lossPct;
            const ackTravel = Math.max(120, delay);

            if (ackWillDrop) {
              logEvent(`ACK for server message id=${id} was lost (simulated).`);
              animateFloating(`ACK_LOST id=${id}`, { 
                direction: 'toServer', 
                duration: ackTravel, 
                dropped: true,
                sender: 'client'
              });
              appendConsole(clientConsole, scpAck(id), 'Client attempted ACK (lost)', 'client');
            } else {
              animateFloating(scpAck(id), { 
                direction: 'toServer', 
                duration: ackTravel, 
                ack: true,
                sender: 'client'
              }).then(() => handleServerAck(id));
              appendConsole(clientConsole, scpAck(id), 'Client sent ACK', 'client');
              logEvent(`Client sent ACK for server message id=${id}.`);
            }
          }, travelDuration + 80);
        }

        if (state.timer) clearTimeout(state.timer);
        const ackTimeout = Math.max(200, parseInt(timeoutRange.value, 10));
        state.timer = setTimeout(() => {
          if (!activeServerMessages.has(id)) return;
          const s = activeServerMessages.get(id);
          if (s.acked) return;
          logEvent(`ACK timeout for server message id=${id} (try ${s.retries}).`);
          appendConsole(serverConsole, `SCP/1.1 | TIMEOUT | id=${id} | retrying...`, 'Timeout', 'server');
          attemptServerSend(id);
        }, ackTimeout + 20);
      }

      function handleServerAck(id) {
        const state = activeServerMessages.get(id);
        if (!state) {
          appendConsole(serverConsole, `SCP/1.1 | ACK_IGNORED | id=${id} | no active message`, 'Error', 'server');
          return;
        }
        state.acked = true;
        if (state.timer) {
          clearTimeout(state.timer);
          state.timer = null;
        }
        appendConsole(serverConsole, scpAck(id), 'Server received ACK', 'server');
        logEvent(`Server received ACK for message id=${id}.`);
        activeServerMessages.delete(id);
      }

      // Event listeners for forms
      clientSendForm.addEventListener('submit', (ev) => {
        ev.preventDefault();
        const text = clientInput.value.trim();
        if (!text) return;
        clientSend(text);
        clientInput.value = '';
      });

      serverSendForm.addEventListener('submit', (ev) => {
        ev.preventDefault();
        const text = serverInput.value.trim();
        if (!text) return;
        serverSend(text);
        serverInput.value = '';
      });

      clearLogBtn.addEventListener('click', () => {
        eventLog.innerHTML = '';
        clientConsole.innerHTML = '';
        serverConsole.innerHTML = '';
        activeClientMessages.clear();
        activeServerMessages.clear();
        clientMsgCounter = 0;
        serverMsgCounter = 100;
        logEvent('Logs cleared. Ready for two-way communication!');
        
        // Add initial connection messages back
        appendConsole(clientConsole, 'SCP/1.1 | HELLO | id=0 | User123', 'Client connected', 'client');
        appendConsole(clientConsole, '[Connected to server]', 'Status', 'client');
        appendConsole(serverConsole, 'SCP/1.1 | ACK | id=0 | CONNECTION_ESTABLISHED', 'Server responded', 'server');
        appendConsole(serverConsole, '[Ready for bidirectional communication]', 'Status', 'server');
      });

      // Initialize with welcome messages
      logEvent('Two-way simulator ready! Send messages from both sides.');
      setTimeout(() => {
        serverSend("Welcome to Two-Way SCP! I'm the server and can send messages too.");
      }, 1000);
    }

    // Initialize simulator when switching to that tab
    document.querySelectorAll('.tab-btn, .top-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const targetTab = btn.dataset.tab;
        
        if (targetTab === 'simulator') {
          setTimeout(() => initSimulator(), 100);
        }
      });
    });
  </script>
</body>
</html>
